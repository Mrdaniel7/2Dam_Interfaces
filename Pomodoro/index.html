<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Focus Grove 3D</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --text-color: #f0f0f0;
            --primary-color: #4a90e2;
            --secondary-color: #e24a4a;
            --ui-bg: rgba(26, 26, 26, 0.8);
            --font-main: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            font-family: var(--font-main);
            background-color: var(--bg-color);
            color: var(--text-color);
        }

        #bg {
            position: fixed;
            top: 0;
            left: 0;
            outline: none;
            width: 100%;
            height: 100%;
        }
        
        body.duel-active #bg {
            cursor: crosshair;
        }

        #ui-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allows clicks to pass through to the canvas unless on a UI element */
        }
        
        #ui-container > * {
            pointer-events: auto; /* Re-enable pointer events for UI elements */
        }

        #timer-display {
            position: absolute;
            top: 45%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(6rem, 20vw, 12rem);
            font-weight: 700;
            color: rgba(255, 255, 255, 0.85);
            text-shadow: 0 0 20px rgba(0,0,0,0.5);
            user-select: none;
            transition: all 0.4s ease;
        }
        
        #timer-display.timer-display-duel {
            top: 20px;
            left: auto;
            right: 20px;
            transform: none;
            font-size: 2rem;
            background-color: var(--ui-bg);
            padding: 5px 15px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .controls {
            position: absolute;
            opacity: 1; /* Make controls visible by default */
            visibility: visible;
            transition: opacity 0.4s ease, visibility 0.4s ease;
            display: flex;
            gap: 15px;
            background-color: var(--ui-bg);
            padding: 10px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #versus-scoreboard, #duel-hud {
            position: absolute;
            opacity: 1; /* Make controls visible by default */
            visibility: visible;
            transition: opacity 0.4s ease, visibility 0.4s ease;
            display: flex;
            gap: 30px;
            background-color: var(--ui-bg);
            padding: 10px 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
        }

        /* Auto-hide UI on inactivity for devices with a mouse */
        @media (pointer: fine) {
            body:not(.duel-active).ui-hidden .controls,
            body:not(.duel-active).ui-hidden #versus-scoreboard,
            body:not(.duel-active).ui-hidden #duel-hud {
                opacity: 0;
                visibility: hidden;
            }
        }


        #main-controls {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
        }

        #top-right-controls {
            top: 20px;
            right: 20px;
            align-items: center;
        }
        
        #top-left-controls {
            top: 20px;
            left: 20px;
        }
        
        #speed-controls {
            bottom: 20px;
            left: 20px;
            gap: 5px;
            align-items: center;
        }
        
        #speed-options {
            display: flex;
            gap: 5px;
        }

        .speed-button {
            width: auto;
            padding: 0 15px;
            border-radius: 10px;
            height: 44px;
        }

        .speed-button.active {
            background-color: var(--primary-color);
            color: white;
        }


        .control-button, .modal-button {
            background: none;
            border: none;
            color: var(--text-color);
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s ease, transform 0.2s ease;
        }
        
        .control-button {
            width: 44px;
            height: 44px;
            border-radius: 50%;
        }

        .control-button:hover {
            background-color: rgba(255, 255, 255, 0.1);
            transform: scale(1.1);
        }

        .control-button svg {
            width: 24px;
            height: 24px;
            fill: currentColor;
        }
        
        #sound-panel {
            position: absolute;
            top: 80px;
            left: 20px;
            width: 220px;
            flex-direction: column;
            gap: 10px;
            align-items: center;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: opacity 0.3s ease, transform 0.3s ease, visibility 0.3s;
        }

        #sound-panel.active {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }
        
        #sound-buttons {
            display: flex;
            gap: 10px;
            width: 100%;
            justify-content: space-around;
        }
        
        .sound-button.active {
            background-color: var(--primary-color);
            color: white;
        }

        #volume-slider {
            width: 90%;
            margin-top: 10px;
        }
        
        /* Modal Styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            z-index: 1000;
            pointer-events: auto;
        }
        
        .modal.active {
            opacity: 1;
            visibility: visible;
        }
        
        .modal-content {
            position: relative;
            background-color: var(--ui-bg);
            padding: 30px;
            border-radius: 16px;
            width: 90%;
            max-width: 500px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            transform: scale(0.95);
            transition: transform 0.3s ease;
        }

        .modal.active .modal-content {
            transform: scale(1);
        }

        .modal-content h2, .modal-content h3 {
            margin-bottom: 1rem;
            text-align: center;
            font-weight: bold;
        }

        .modal-content .form-group {
            margin-bottom: 15px;
        }

        .modal-content label {
            display: block;
            margin-bottom: 5px;
            color: rgba(255,255,255,0.7);
        }

        .modal-content input[type="number"], .modal-content input[type="text"], .modal-content select, .modal-content textarea, .modal-content input[type="file"] {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.2);
            background-color: rgba(0,0,0,0.3);
            color: var(--text-color);
            font-size: 1rem;
        }
        
        .modal-button {
            width: 100%;
            padding: 12px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: bold;
            background-color: var(--primary-color);
            margin-top: 10px;
        }
        
        .modal-button.secondary {
            background-color: #555;
        }
        
        .modal-button:hover {
            transform: scale(1.03);
            opacity: 0.9;
        }

        .modal-button:disabled {
            background-color: #555;
            cursor: not-allowed;
            transform: none;
        }

        #task-list {
            list-style: none;
            max-height: 150px;
            overflow-y: auto;
            margin-bottom: 15px;
        }
        
        #task-list li {
            display: flex;
            align-items: center;
            padding: 8px;
            border-radius: 6px;
            transition: background-color 0.2s;
        }
        
        #task-list li:hover {
            background-color: rgba(255,255,255,0.1);
        }
        
        #task-list li.completed span {
            text-decoration: line-through;
            opacity: 0.5;
        }
        
        #task-list input[type="checkbox"] {
           margin-right: 10px;
           min-width: 16px;
           min-height: 16px;
       }

        #task-list .delete-task {
            margin-left: auto;
            background: none;
            border: none;
            color: #ff6b6b;
            cursor: pointer;
            opacity: 0.5;
            transition: opacity 0.2s;
        }
        
        #task-list li:hover .delete-task {
            opacity: 1;
        }

        .modal-close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            color: var(--text-color);
            font-size: 1.5rem;
            cursor: pointer;
        }
        
        #ai-tutor-loading .spinner {
            border-color: rgba(255,255,255,0.2);
            border-top-color: var(--primary-color);
        }

        #language-btn {
            width: 2.5rem;
            height: 1.75rem;
            background-size: cover;
            background-position: center;
            border-radius: 0.25rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .dropdown-menu {
            position: absolute;
            top: 54px;
            width: 220px;
            display: flex;
            flex-direction: column;
            align-items: stretch;
            gap: 0;
            padding: 5px;
            background-color: var(--ui-bg);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 20;
        }
        #language-dropdown {
            right: 0;
            width: 180px;
        }
        #main-menu-dropdown {
            left: 0;
        }
        .menu-option {
            display: flex;
            align-items: center;
            gap: 12px;
            width: 100%;
            text-align: left;
            padding: 10px 12px;
            background: none;
            border: none;
            color: var(--text-color);
            cursor: pointer;
            border-radius: 8px;
            transition: background-color 0.2s;
            font-size: 0.9rem;
        }
        .menu-option:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .menu-option svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
            flex-shrink: 0;
        }

        .hidden {
            display: none !important;
        }

        .relative {
            position: relative;
        }
        
        .menu-option.mobile-only {
            display: none;
        }

        @media (max-width: 768px) {
            .menu-option.mobile-only {
                display: flex;
            }
            #top-right-controls .relative, /* Language button container */
            #fullscreen-btn-container {
                display: none;
            }
        }
        
        #game-code-display-container {
            position: relative;
        }

        #game-code-display {
            background-color: rgba(0,0,0,0.4);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            font-size: 2rem;
            font-weight: bold;
            letter-spacing: 4px;
            margin: 20px 0;
            border: 1px dashed rgba(255,255,255,0.3);
        }
        
        #copy-code-btn {
            position: absolute;
            top: 50%;
            right: 10px;
            transform: translateY(-50%);
            background-color: rgba(255,255,255,0.1);
            border-radius: 8px;
            border: none;
            cursor: pointer;
            padding: 8px;
        }

        #copy-code-btn:hover {
            background-color: rgba(255,255,255,0.2);
        }

        #copy-code-btn svg {
            width: 20px;
            height: 20px;
            fill: var(--text-color);
        }

        #game-code-copy-feedback {
            text-align: center;
            font-size: 0.9rem;
            color: var(--primary-color);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .player-score {
            text-align: center;
        }

        .player-score h4 {
            font-size: 1rem;
            margin-bottom: 5px;
        }
        
        .player-score-counters {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .player-score-counters p {
            font-size: 1.5rem;
            font-weight: bold;
        }
        
        #player1-score h4 { color: var(--primary-color); }
        #player2-score h4 { color: var(--secondary-color); }

        /* Shooter Minigame Styles */
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.7);
            font-size: 24px;
            font-weight: bold;
            pointer-events: none;
            display: none;
        }
        body.duel-active #crosshair {
            display: block;
        }
        
        #duel-mode-btn {
            position: absolute;
            top: 65%; /* Positioned below the main timer */
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            background: linear-gradient(145deg, #4b0082, #2e8b57); /* Purple to Green gradient */
            color: white;
            border: 2px solid #333;
            border-radius: 12px;
            font-weight: bold;
            font-size: 1.2rem;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            box-shadow: 0 0 10px #2e8b57, 0 0 20px #2e8b57, inset 0 0 5px rgba(0,0,0,0.5);
            transition: all 0.3s ease;
            z-index: 50;
            text-shadow: 1px 1px 3px black;
        }
        #duel-mode-btn:hover {
            transform: translateX(-50%) scale(1.05);
            box-shadow: 0 0 15px #3cff9c, 0 0 30px #3cff9c, inset 0 0 5px rgba(0,0,0,0.5);
            border-color: #3cff9c;
        }
        #duel-mode-btn:disabled {
            background: #555;
            cursor: not-allowed;
            transform: translateX(-50%) scale(1);
            box-shadow: none;
            border-color: #333;
        }
        
        #class-selection-modal .modal-content {
            max-width: 900px;
        }
        #class-selection-container {
            display: flex;
            gap: 20px;
            justify-content: center;
        }
        .class-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 20px;
            width: 250px;
            text-align: center;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            cursor: pointer;
        }
        .class-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
            border-color: var(--primary-color);
        }
        .class-card h3 {
            color: var(--primary-color);
            margin-bottom: 15px;
        }
        .class-card p {
            font-size: 0.9rem;
            color: rgba(255,255,255,0.7);
            margin-bottom: 5px;
        }

        #duel-hud {
            gap: 30px;
            align-items: center;
            font-weight: bold;
        }

        #duel-score {
            font-size: 2.5rem;
            color: white;
        }

        .health-bar-container {
            width: 150px;
            height: 20px;
            background: rgba(0,0,0,0.4);
            border-radius: 10px;
            padding: 3px;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .health-bar {
            height: 100%;
            width: 100%;
            border-radius: 7px;
            transition: width 0.3s ease;
        }
        
        #remote-player-health-bar { background-color: var(--secondary-color); }

        #remote-player-duel-hud {
            text-align: left;
        }

        #local-player-duel-hud {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: var(--ui-bg);
            padding: 10px 15px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            width: 250px;
        }

        #local-player-duel-hud h4 {
            margin-bottom: 8px;
            font-size: 1rem;
            color: var(--primary-color);
        }

        #local-player-duel-hud .health-bar-container {
            width: 100%;
            height: 25px;
        }
        
        #local-player-health-bar {
            background-color: var(--primary-color);
        }


        #duel-results-modal .modal-content {
            text-align: center;
        }
        #duel-winner-text {
            font-size: 2rem;
            margin-bottom: 1rem;
        }
        
        #credit-line {
            user-select: none;
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            transition: color 0.2s;
        }
        #credit-line:hover {
            color: rgba(255, 255, 255, 0.7);
        }

    </style>
</head>
<body>

    <canvas id="bg"></canvas>

    <div id="ui-container">
        <div id="crosshair">+</div>
        <div id="timer-display">25:00</div>
        <button id="duel-mode-btn" class="hidden">🧟‍♂️ Modo Zombi 🧟‍♂️</button>
        
        <div id="versus-scoreboard" class="hidden">
            <div id="player1-score" class="player-score">
                <h4 data-translate-key="host">Anfitrión</h4>
                <div class="player-score-counters">
                    <p class="pomodoro-count">0 🍅</p>
                    <p class="tree-count">0 🌳</p>
                </div>
            </div>
             <div id="player2-score" class="player-score">
                <h4 data-translate-key="guest">Invitado</h4>
                <div class="player-score-counters">
                    <p class="pomodoro-count">0 🍅</p>
                    <p class="tree-count">0 🌳</p>
                </div>
            </div>
        </div>

        <!-- DUEL HUD -->
        <div id="local-player-duel-hud" class="hidden">
            <h4 id="local-player-name-hud">Tú</h4>
            <div class="health-bar-container">
                <div id="local-player-health-bar" class="health-bar"></div>
            </div>
        </div>

        <div id="duel-hud" class="hidden">
            <div id="duel-score">0 - 0</div>
            <div id="remote-player-duel-hud">
                <h4 id="remote-player-name-hud">Oponente</h4>
                <div class="health-bar-container">
                    <div id="remote-player-health-bar" class="health-bar"></div>
                </div>
            </div>
        </div>

        <!-- ZOMBIE MODE HUD -->
        <div id="zombie-hud" class="hidden" style="position: absolute; top: 80px; left: 20px; background-color: var(--ui-bg); padding: 10px 15px; border-radius: 12px; backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.1);">
            <h4 style="margin-bottom: 5px;"><span data-translate-key="zombieRound">Ronda:</span> <span id="zombie-round-display">1</span></h4>
            <h4><span data-translate-key="zombieKills">Bajas:</span> <span id="zombie-kills-display">0</span></h4>
        </div>


        <div id="main-controls" class="controls">
            <button id="play-pause-btn" class="control-button" title="Play/Pause">
                <svg id="play-icon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"></path></svg>
                <svg id="pause-icon" viewBox="0 0 24 24" style="display:none;"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"></path></svg>
            </button>
             <button id="reset-btn" class="control-button" title="Reset">
                <svg viewBox="0 0 24 24"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"></path></svg>
            </button>
        </div>

        <div id="top-right-controls" class="controls">
            <button id="ai-tutor-btn" class="control-button font-bold text-lg" title="Tutor IA">AI</button>
            
            <div class="relative">
                <button id="language-btn" title="Cambiar Idioma"></button>
                <div id="language-dropdown" class="dropdown-menu hidden">
                    <button data-lang="es" class="menu-option"><span class="w-6 h-4 bg-cover bg-center rounded-sm" style="background-image: url('https://flagcdn.com/w40/es.png');"></span><span class="flex-1">Español</span></button>
                    <button data-lang="en" class="menu-option"><span class="w-6 h-4 bg-cover bg-center rounded-sm" style="background-image: url('https://flagcdn.com/w40/us.png');"></span><span class="flex-1">English</span></button>
                    <button data-lang="fr" class="menu-option"><span class="w-6 h-4 bg-cover bg-center rounded-sm" style="background-image: url('https://flagcdn.com/w40/fr.png');"></span><span class="flex-1">Français</span></button>
                    <button data-lang="zh" class="menu-option"><span class="w-6 h-4 bg-cover bg-center rounded-sm" style="background-image: url('https://flagcdn.com/w40/cn.png');"></span><span class="flex-1">中文</span></button>
                    <button data-lang="hi" class="menu-option"><span class="w-6 h-4 bg-cover bg-center rounded-sm" style="background-image: url('https://flagcdn.com/w40/in.png');"></span><span class="flex-1">हिन्दी</span></button>
                </div>
            </div>

            <div id="fullscreen-btn-container">
                <button id="fullscreen-btn" class="control-button" title="Pantalla Completa">
                    <svg viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"></path></svg>
                </button>
            </div>
        </div>

        <div id="top-left-controls" class="controls">
            <div class="relative">
                <button id="main-menu-btn" class="control-button" title="Menú">
                    <svg viewBox="0 0 24 24"><path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path></svg>
                </button>
                <div id="main-menu-dropdown" class="dropdown-menu hidden">
                    <button id="settings-btn" class="menu-option" title="Configuración">
                        <svg viewBox="0 0 24 24"><path d="M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61-.25-1.17-.59-1.69.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19.15-.24-.42-.12-.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49.42l.38-2.65c.61-.25 1.17-.59-1.69.98l2.49 1c.23.09.49 0 .61.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z"></path></svg>
                        <span data-translate-key="settingsTitle">Configuración</span>
                    </button>
                    <button id="tasks-btn" class="menu-option" title="Tareas">
                        <svg viewBox="0 0 24 24"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"></path></svg>
                        <span data-translate-key="todoTitle">Lista de Tareas</span>
                    </button>
                    <button id="multiplayer-btn" class="menu-option" title="Multijugador" disabled>
                         <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"/></svg>
                        <span data-translate-key="multiplayer">Multijugador</span>
                    </button>
                    <button id="biome-btn" class="menu-option" title="Cambiar Bioma">
                        <svg viewBox="0 0 24 24"><path d="M15 6l-2.5 4L10 4l-5 12h16l-6-8z"></path></svg>
                        <span data-translate-key="biome">Bioma</span>
                    </button>
                    <button id="sound-menu-btn" class="menu-option" title="Sonido Ambiente">
                       <svg viewBox="0 0 24 24"><path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/></svg>
                       <span data-translate-key="music">Música</span>
                   </button>
                <button id="language-menu-btn" class="menu-option mobile-only">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"/></svg>
                        <span data-translate-key="language">Idioma</span>
                    </button>
                    <button id="fullscreen-menu-btn" class="menu-option mobile-only">
                         <svg viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"></path></svg>
                        <span data-translate-key="fullscreen">Pantalla Completa</span>
                    </button>
                </div>
            </div>
        </div>
        
        <div id="speed-controls" class="controls">
             <button id="speed-toggle-btn" class="speed-button" data-speed="1">x1</button>
            <div id="speed-options" class="hidden">
                <button class="speed-button" data-speed="1">x1</button>
                <button class="speed-button" data-speed="2">x2</button>
                <button class="speed-button" data-speed="5">x5</button>
                <button class="speed-button" data-speed="10">x10</button>
                <button class="speed-button" data-speed="100">x100</button>
            </div>
        </div>

        <div id="sound-panel" class="controls">
            <div id="sound-buttons">
                <button class="control-button sound-button" data-sound="rain" title="Lluvia">
                    <svg viewBox="0 0 24 24"><path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM17 19H6c-2.21 0-4-1.79-4-4s1.79-4 4-4h.71C7.37 9.69 9.54 8 12 8c2.65 0 4.88 1.99 5.29 4.58A3.003 3.003 0 0 1 21 14c0 1.66-1.34 3-3 3h-1v2z"/></svg>
                </button>
                <button class="control-button sound-button" data-sound="forest" title="Bosque">
                   <svg viewBox="0 0 24 24"><path d="M22.2,8.6c-0.1-0.1-0.2-0.2-0.4-0.2c-0.3-0.2-0.7-0.1-0.9,0.1c-1.3,1-3.1,1.5-4.9,1.5c-1,0-2-0.2-2.9-0.5 c-0.5-0.2-1-0.1-1.4,0.3l-1,1c-0.2,0.2-0.2,0.5,0,0.7s0.5,0.2,0.7,0l1-1c0.1-0.1,0.2-0.1,0.3-0.1c0.8,0.3,1.7,0.4,2.6,0.4 c1.6,0,3.3-0.5,4.5-1.4c0.3-0.2,0.7-0.2,0.9,0.1C22.1,10.9,22.4,10.1,22.2,8.6z M17,14c-1.7,0-3-1.3-3-3s1.3-3,3-3s3,1.3,3,3 S18.7,14,17,14z M7,10C5.3,10,4,8.7,4,7s1.3-3,3-3s3,1.3,3,3S8.7,10,7,10z"/></svg>
                </button>
                <button class="control-button sound-button" data-sound="white_noise" title="Ruido Blanco">
                    <svg viewBox="0 0 24 24"><path d="M3 9h2v6H3V9zm4 0h2v6H7V9zm4 0h2v6h-2V9zm4 0h2v6h-2V9zm4 0h2v6h-2V9z"/></svg>
                </button>
                <button class="control-button sound-button active" data-sound="mute" title="Silencio">
                    <svg viewBox="0 0 24 24"><path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/></svg>
                </button>
            </div>
            <input type="range" id="volume-slider" min="0" max="100" value="50">
        </div>

    </div>
    
    <!-- Settings Modal --><div id="settings-modal" class="modal">
        <div class="modal-content">
            <button class="modal-close-btn" data-target="settings-modal">&times;</button>
            <h2 data-translate-key="settingsTitle">Configuración</h2>
            <div class="form-group">
                <label data-translate-key="focusLabel">Enfoque</label>
                <input type="number" id="focus-duration" value="25" min="1">
            </div>
            <div class="form-group">
                <label data-translate-key="shortBreakLabel">Descanso Corto</label>
                <input type="number" id="short-break-duration" value="5" min="1">
            </div>
            <div class="form-group">
                <label data-translate-key="longBreakLabel">Descanso Largo</label>
                <input type="number" id="long-break-duration" value="15" min="1">
            </div>
            <hr style="border-color: rgba(255,255,255,0.2); margin: 20px 0;">
            <h3 data-translate-key="saveLoadGame">Guardar/Cargar Partida</h3>
            <p style="font-size: 0.9rem; color: #aaa; margin-bottom: 15px;" data-translate-key="saveLoadDesc">Exporta el estado de tu partida multijugador para continuarla más tarde.</p>
            <div class="form-group">
                <button id="export-game-btn" class="modal-button secondary" data-translate-key="exportGame">Exportar Partida</button>
            </div>
             <div class="form-group">
                <label for="import-game-input" data-translate-key="importGame">Importar Partida (Anfitrión)</label>
                <input type="file" id="import-game-input" accept=".json" style="padding: 5px;">
            </div>
        </div>
    </div>
    
    <!-- Tasks Modal --><div id="tasks-modal" class="modal">
        <div class="modal-content">
            <button class="modal-close-btn" data-target="tasks-modal">&times;</button>
            <h2 data-translate-key="todoTitle">Lista de Tareas</h2>
            <ul id="task-list"></ul>
            <div class="form-group">
                <input type="text" id="new-task-input" placeholder="Añadir nueva tarea..." data-translate-key="todoPlaceholder">
            </div>
        </div>
    </div>

    <!-- AI Modal -->
    <div id="ai-tutor-modal" class="modal">
         <div class="modal-content">
            <button class="modal-close-btn" data-target="ai-tutor-modal">&times;</button>
            <h3 class="text-lg font-bold mb-4" data-translate-key="aiTutorTitle">✨ Tutor IA</h3>
            <p class="text-sm text-secondary mb-4" data-translate-key="aiTutorDescription">¿Atascado en un problema? Descríbelo y la IA te dará una explicación simple.</p>
            <textarea id="ai-tutor-prompt-input" rows="4" class="w-full p-2 rounded-md bg-primary-light border border-custom text-sm mb-4" placeholder="Ej: ¿Por qué el cielo es azul?" data-translate-key="aiTutorPlaceholder"></textarea>
            <button id="ai-tutor-generate-btn" class="w-full font-bold py-2 px-4 rounded-lg text-white transition-transform transform hover:scale-105" style="background-color: var(--primary-color);">
                <span data-translate-key="aiTutorGenerateBtn">Explicar Concepto</span>
            </button>
            <div id="ai-tutor-result-container" class="mt-4 max-h-48 overflow-y-auto">
                <div id="ai-tutor-loading" class="hidden flex-col items-center justify-center text-center">
                     <div class="spinner w-8 h-8 border-4 rounded-full animate-spin"></div>
                    <p class="text-sm text-secondary" data-translate-key="aiTutorLoading">Pensando...</p>
                </div>
                <div id="ai-tutor-output" class="text-left text-sm space-y-2"></div>
            </div>
        </div>
    </div>

    <!-- Multiplayer Modal -->
    <div id="multiplayer-modal" class="modal">
        <div class="modal-content">
             <button class="modal-close-btn" data-target="multiplayer-modal">&times;</button>

            <!-- Initial View -->
            <div id="multiplayer-initial">
                <h2 data-translate-key="multiplayer">Multijugador</h2>
                <button id="host-btn" class="modal-button" data-translate-key="createGame">Crear Partida</button>
                <button id="join-btn" class="modal-button secondary" data-translate-key="joinGame">Unirse a Partida</button>
            </div>

            <!-- Host: Mode Selection -->
            <div id="multiplayer-host-options" class="hidden">
                <h2 data-translate-key="selectMode">Seleccionar Modo</h2>
                <button id="coop-mode-btn" class="modal-button">🤝 <span data-translate-key="cooperativeMode">Cooperativo</span></button>
                <button id="versus-mode-btn" class="modal-button secondary">⚔️ <span data-translate-key="versusMode">Lucha</span></button>
                <button id="back-to-initial-btn" class="modal-button" style="background-color:#6c757d; margin-top:20px;" data-translate-key="back">Volver</button>
            </div>

            <!-- Host: Waiting for Player -->
            <div id="multiplayer-waiting" class="hidden">
                <h2 data-translate-key="waitingForPlayer">Esperando jugador...</h2>
                <p style="text-align:center; margin-bottom:1rem;" data-translate-key="shareCode">Comparte este código con un amigo:</p>
                <div id="game-code-display-container">
                    <div id="game-code-display">CÓDIGO</div>
                    <button id="copy-code-btn" title="Copiar Código">
                        <svg viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg>
                    </button>
                </div>
                <p id="game-code-copy-feedback" data-translate-key="copied">¡Copiado!</p>
            </div>
            
            <!-- Guest: Join Game -->
            <div id="multiplayer-join" class="hidden">
                <h2 data-translate-key="joinGame">Unirse a Partida</h2>
                <div class="form-group">
                    <label for="game-code-input" data-translate-key="enterCode">Introduce el código de la partida</label>
                    <input type="text" id="game-code-input" placeholder="CÓDIGO-AQUÍ">
                </div>
                <button id="join-game-submit-btn" class="modal-button" data-translate-key="join">Unirse</button>
                 <button id="back-to-initial-btn-2" class="modal-button" style="background-color:#6c757d; margin-top:10px;" data-translate-key="back">Volver</button>
            </div>
        </div>
    </div>

    <!-- Class Selection Modal -->
    <div id="class-selection-modal" class="modal">
        <div class="modal-content">
            <h2>Selecciona tu Clase</h2>
            <p style="text-align:center; margin-bottom: 2rem; color: #aaa;">Elige tu estilo de combate.</p>
            <div id="class-selection-container">
                <div class="class-card" data-class="scout">
                    <h3>🏃‍♂️ Explorador</h3>
                    <p><strong>Vida:</strong> 75</p>
                    <p><strong>Velocidad:</strong> Muy Rápida</p>
                    <p><strong>Arma:</strong> Pistola (Daño bajo, cadencia alta)</p>
                </div>
                <div class="class-card" data-class="soldier">
                    <h3>⚔️ Soldado</h3>
                    <p><strong>Vida:</strong> 100</p>
                    <p><strong>Velocidad:</strong> Normal</p>
                    <p><strong>Arma:</strong> Rifle (Daño medio, cadencia media)</p>
                </div>
                <div class="class-card" data-class="tank">
                    <h3>🛡️ Tanque</h3>
                    <p><strong>Vida:</strong> 150</p>
                    <p><strong>Velocidad:</strong> Lenta</p>
                    <p><strong>Arma:</strong> Escopeta (Daño alto, cadencia baja)</p>
                </div>
            </div>
             <p id="waiting-for-opponent-class" class="hidden" style="text-align:center; margin-top: 1.5rem;">Esperando al oponente...</p>
        </div>
    </div>
    
    <!-- Duel Results Modal -->
    <div id="duel-results-modal" class="modal">
        <div class="modal-content">
            <h2 id="duel-winner-text">¡Duelo Terminado!</h2>
            <p id="final-duel-score" style="font-size: 1.5rem; margin-bottom: 1rem;">0 - 0</p>
            <button id="close-duel-results-btn" class="modal-button">Continuar</button>
        </div>
    </div>

    <!-- ZOMBIE DEATH MODAL -->
    <div id="zombie-death-modal" class="modal">
        <div class="modal-content" style="text-align: center;">
            <h2>¡Has muerto!</h2>
            <p style="margin-bottom: 1rem;">Has sobrevivido hasta la <span id="death-modal-round">1</span> con <span id="death-modal-kills">0</span> bajas.</p>
            <button id="zombie-respawn-btn" class="modal-button">Reintentar desde el principio</button>
            <button id="zombie-exit-btn" class="modal-button secondary">Salir del modo</button>
        </div>
    </div>

    <!-- ZOMBIE RESULTS MODAL -->
    <div id="zombie-results-modal" class="modal">
        <div class="modal-content" style="text-align: center;">
            <h2>¡Tiempo agotado!</h2>
            <p style="font-size: 1.2rem; margin-bottom: 1rem;">Has llegado a la <strong id="results-modal-round">1</strong> con <strong id="results-modal-kills">0</strong> bajas.</p>
            <button id="close-zombie-results-btn" class="modal-button">Continuar</button>
        </div>
    </div>


    <!-- Load Tone.js via a classic script tag before the module script --><script src="https://cdn.jsdelivr.net/npm/tone@14.7.77/build/Tone.min.js"></script>
    <!-- Improved Perlin Noise library for more natural terrain --><script src="https://cdn.jsdelivr.net/npm/simplex-noise@2.4.0/simplex-noise.min.js"></script>

    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, updateDoc, onSnapshot, collection, increment, arrayUnion, arrayRemove } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- DOM ELEMENTS ---
        const canvas = document.getElementById('bg');
        const timerDisplay = document.getElementById('timer-display');
        
        const playPauseBtn = document.getElementById('play-pause-btn');
        const playIcon = document.getElementById('play-icon');
        const pauseIcon = document.getElementById('pause-icon');
        const resetBtn = document.getElementById('reset-btn');
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        const settingsBtn = document.getElementById('settings-btn');
        const tasksBtn = document.getElementById('tasks-btn');
        const biomeBtn = document.getElementById('biome-btn');
        const soundMenuBtn = document.getElementById('sound-menu-btn');
        const soundPanel = document.getElementById('sound-panel');
        const volumeSlider = document.getElementById('volume-slider');
        
        // Modals
        const settingsModal = document.getElementById('settings-modal');
        const tasksModal = document.getElementById('tasks-modal');
        const workDurationInput = document.getElementById('focus-duration');
        const shortBreakDurationInput = document.getElementById('short-break-duration');
        const longBreakDurationInput = document.getElementById('long-break-duration');
        
        // AI Tutor
        const aiTutorModal = document.getElementById('ai-tutor-modal');
        const aiTutorBtn = document.getElementById('ai-tutor-btn');
        const aiTutorGenerateBtn = document.getElementById('ai-tutor-generate-btn');
        const aiTutorPromptInput = document.getElementById('ai-tutor-prompt-input');
        const aiTutorLoading = document.getElementById('ai-tutor-loading');
        const aiTutorOutput = document.getElementById('ai-tutor-output');

        // Language
        const languageBtn = document.getElementById('language-btn');
        const languageDropdown = document.getElementById('language-dropdown');
        
        // Main Menu
        const mainMenuBtn = document.getElementById('main-menu-btn');
        const mainMenuDropdown = document.getElementById('main-menu-dropdown');
        const languageMenuBtn = document.getElementById('language-menu-btn');
        const fullscreenMenuBtn = document.getElementById('fullscreen-menu-btn');


        // Tasks
        const newTaskInput = document.getElementById('new-task-input');
        const taskList = document.getElementById('task-list');
        
        // Multiplayer UI
        const multiplayerBtn = document.getElementById('multiplayer-btn');
        const multiplayerModal = document.getElementById('multiplayer-modal');
        const multiplayerInitialView = document.getElementById('multiplayer-initial');
        const multiplayerHostView = document.getElementById('multiplayer-host-options');
        const multiplayerWaitingView = document.getElementById('multiplayer-waiting');
        const multiplayerJoinView = document.getElementById('multiplayer-join');
        const hostBtn = document.getElementById('host-btn');
        const joinBtn = document.getElementById('join-btn');
        const coopModeBtn = document.getElementById('coop-mode-btn');
        const versusModeBtn = document.getElementById('versus-mode-btn');
        const gameCodeDisplay = document.getElementById('game-code-display');
        const gameCodeInput = document.getElementById('game-code-input');
        const joinGameSubmitBtn = document.getElementById('join-game-submit-btn');
        const copyCodeBtn = document.getElementById('copy-code-btn');
        const versusScoreboard = document.getElementById('versus-scoreboard');
        const exportGameBtn = document.getElementById('export-game-btn');
        const importGameInput = document.getElementById('import-game-input');

        // Duel Minigame UI
        const duelModeBtn = document.getElementById('duel-mode-btn');
        const classSelectionModal = document.getElementById('class-selection-modal');
        const duelHud = document.getElementById('duel-hud');
        const localPlayerDuelHud = document.getElementById('local-player-duel-hud');
        const duelScoreDisplay = document.getElementById('duel-score');
        const localPlayerHealthBar = document.getElementById('local-player-health-bar');
        const remotePlayerHealthBar = document.getElementById('remote-player-health-bar');
        const duelResultsModal = document.getElementById('duel-results-modal');

        // Speed Controls
        const speedControls = document.getElementById('speed-controls');
        const speedToggleBtn = document.getElementById('speed-toggle-btn');
        const speedOptions = document.getElementById('speed-options');
        let speedTimeoutId = null;

        // UI Inactivity
        let inactivityTimer = null;


        // --- 3D SCENE SETUP ---
        let scene, camera, renderer, sunLight, floor, skybox, sunMesh;
        let orbitControls, pointerLockControls;
        let grove = [];
        const shrubsGroup = new THREE.Group();
        const flowersGroup = new THREE.Group();
        let noise;
        
        // --- FIREBASE & APP STATE ---
        let db, auth, userId;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        let currentGameState = {
            inMultiplayer: false,
            isHost: false,
            gameId: null,
            mode: null,
            unsubscribe: null,
            playerCount: 1,
            playerIds: [],
        };

        // --- SINGLE PLAYER DUEL TEST ---
        let singlePlayerDuelEnabled = true;

        // --- SHOOTER MINIGAME STATE ---
        const duelState = {
            active: false,
            status: 'inactive', // 'inactive', 'selecting', 'active', 'finished'
            players: {},
            projectiles: [],
            localPlayer: null,
            remotePlayer: null,
        };
        const CLASS_STATS = {
            scout:   { maxHealth: 75,  speed: 9, jumpHeight: 12, weapon: { damage: 8,  fireRate: 150, range: 80, projectileSpeed: 100 } },
            soldier:{ maxHealth: 100, speed: 7, jumpHeight: 10, weapon: { damage: 15, fireRate: 300, range: 120, projectileSpeed: 80 } },
            tank:    { maxHealth: 150, speed: 5, jumpHeight: 8,  weapon: { damage: 35, fireRate: 800, range: 40, projectileSpeed: 60 } }
        };
        const zombieModeState = {
            active: false,
            round: 0,
            kills: 0,
            zombies: [],
            zombiesToSpawn: 0,
            waveTimer: 0,
            waveInterval: 30, // 30 seconds between waves if not cleared
        };
        
        let preZombieState = {
            mode: 'focus',
            currentTime: 0
        };
        let zombieModeStartTime = 0;


        function init3D(mapSeed = 'default-seed', biomeIndex = 0) {
            if(scene) { // Clear existing scene if any
                while(scene.children.length > 0){ 
                    scene.remove(scene.children[0]); 
                }
            } else {
                 scene = new THREE.Scene();
            }
           
            noise = new SimplexNoise(mapSeed);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            orbitControls = new OrbitControls(camera, renderer.domElement);
            orbitControls.enableDamping = true;
            orbitControls.minDistance = 5;
            orbitControls.maxDistance = 80; 
            orbitControls.maxPolarAngle = Math.PI / 2.1;
            camera.position.set(0, 20, 50);


            pointerLockControls = new PointerLockControls(camera, document.body);
            scene.add(pointerLockControls.getObject());

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
            sunLight.position.set(50, 50, -50);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 200;
            const shadowCamSize = 120;
            sunLight.shadow.camera.left = -shadowCamSize;
            sunLight.shadow.camera.right = shadowCamSize;
            sunLight.shadow.camera.top = shadowCamSize;
            sunLight.shadow.camera.bottom = -shadowCamSize;
            scene.add(sunLight);

            const floorSize = 200;
            const floorSegments = 100;
            const floorGeometry = new THREE.PlaneGeometry(floorSize, floorSize, floorSegments, floorSegments);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                vertexColors: true,
                roughness: 0.8,
                metalness: 0.1
            });
            
            const vertices = floorGeometry.attributes.position;
            const colors = [];
            const color = new THREE.Color();
            
            const grassColor = new THREE.Color(0x4CAF50);
            const darkGrassColor = new THREE.Color(0x388E3C);
            const rockColor = new THREE.Color(0x757575);
            
            for (let i = 0; i < vertices.count; i++) {
                const x = vertices.getX(i);
                const y = vertices.getY(i);
                
                const height = getHeightAt(x, y); 
                vertices.setZ(i, height);
                
                const heightRatio = Math.max(0, height / 20);
                if (heightRatio < 0.3) {
                    color.copy(darkGrassColor).lerp(grassColor, heightRatio / 0.3);
                } else {
                    color.copy(grassColor).lerp(rockColor, (heightRatio - 0.3) / 0.7);
                }

                colors.push(color.r, color.g, color.b);
            }
            floorGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            floorGeometry.computeVertexNormals();

            floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);
            
            scene.add(shrubsGroup);
            scene.add(flowersGroup);
            addVegetation();

            const sunGeometry = new THREE.SphereGeometry(7, 32, 32);
            const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xFDB813 });
            sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
            sunMesh.position.set(100, 60, -150);
            scene.add(sunMesh);

            const sunPointLight = new THREE.PointLight(0xFDB813, 0.5, 300);
            sunMesh.add(sunPointLight);

            const skyGeometry = new THREE.BoxGeometry(1000, 1000, 1000);
            const skyMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    topColor: { value: new THREE.Color() },
                    bottomColor: { value: new THREE.Color() },
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * viewMatrix * worldPosition;
                        gl_Position.z = gl_Position.w;
                    }
                `,
                fragmentShader: `
                    uniform vec3 topColor;
                    uniform vec3 bottomColor;
                    varying vec3 vWorldPosition;
                    void main() {
                        float h = normalize(vWorldPosition).y;
                        gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), 0.8), 0.0)), 1.0);
                    }
                `,
                side: THREE.BackSide,
            });
            skybox = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(skybox);

            changeBiome(biomeIndex);
        }

        // --- POMODORO LOGIC ---
        let state = {
            isRunning: false,
            timerId: null,
            mode: 'focus', 
            workDuration: 25 * 60,
            shortBreakDuration: 5 * 60,
            longBreakDuration: 15 * 60,
            currentTime: 25 * 60,
            pomodoroCount: 0,
            timeScale: 1,
            currentLang: 'es'
        };
        
        function updateDurations() {
            state.workDuration = parseInt(workDurationInput.value) * 60;
            state.shortBreakDuration = parseInt(shortBreakDurationInput.value) * 60;
            state.longBreakDuration = parseInt(longBreakDurationInput.value) * 60;
            resetTimer();
        }
        
        function formatTime(seconds) {
            seconds = Math.round(seconds);
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
        }
        
        function updateTimerDisplay() {
            timerDisplay.textContent = formatTime(state.currentTime);
            document.title = `${formatTime(state.currentTime)} - Focus Grove`;
        }

        async function switchMode(newMode) {
            if (zombieModeState.active) {
                endZombieMode(false);
            }
            if (duelState.active) {
                // To be safe, also handle duel mode exit if user changes timer mode
                if (currentGameState.isHost) {
                     const gameRef = doc(db, `artifacts/${appId}/public/data/games`, currentGameState.gameId);
                     updateDoc(gameRef, { 'duel.status': 'finished' });
                }
            }

            state.mode = newMode;
            switch (newMode) {
                case 'focus':
                    state.currentTime = state.workDuration;
                    break;
                case 'shortBreak':
                    state.currentTime = state.shortBreakDuration;
                    break;
                case 'longBreak':
                    state.currentTime = state.longBreakDuration;
                    break;
            }
            // Sync player status in multiplayer
            if (currentGameState.inMultiplayer && currentGameState.mode === 'versus') {
                const gameRef = doc(db, `artifacts/${appId}/public/data/games`, currentGameState.gameId);
                await updateDoc(gameRef, { [`players.${userId}.status`]: newMode });
            }
            updateTimerDisplay();
            updateSinglePlayerDuelButtonVisibility();
        }

        async function timerTick() {
            state.currentTime--;
            updateTimerDisplay();

            if (state.currentTime <= 0) {
                if (zombieModeState.active) {
                    endZombieMode();
                    return;
                }
                if (duelState.active) {
                    if(currentGameState.inMultiplayer) {
                        if(currentGameState.isHost) {
                            const gameRef = doc(db, `artifacts/${appId}/public/data/games`, currentGameState.gameId);
                            await updateDoc(gameRef, { 'duel.status': 'finished' });
                        }
                    }
                    return;
                }
            }


            if (state.mode === 'focus' && state.currentTime > 0) {
                let shouldGrow = false;
                if (currentGameState.inMultiplayer && currentGameState.mode === 'cooperative') {
                    const interval = currentGameState.playerCount >= 3 ? 120 : 60; // 2 minutes if 3+ players
                    if (state.currentTime % interval === 0) shouldGrow = true;
                } else {
                    if (state.currentTime % 60 === 0) shouldGrow = true;
                }
                if (shouldGrow) {
                    growATree({ isSpecial: false, taskId: null });
                }
            }

            if (!duelState.active && state.currentTime <= 0) {
                pauseTimer(); 
                playNotification();

                if (state.mode === 'focus') {
                    state.pomodoroCount++;
                    await growATree({ isSpecial: false, taskId: null, isPomodoroCompletion: true }); 
                    
                    if (state.pomodoroCount > 0 && state.pomodoroCount % 4 === 0) {
                        await switchMode('longBreak');
                    } else {
                        await switchMode('shortBreak');
                    }
                } else {
                    await switchMode('focus');
                }
            }
        }

        function startTimer() {
            if (state.isRunning) return;
            startAudioContext();
            state.isRunning = true;
            if(state.timerId) clearInterval(state.timerId);
            state.timerId = setInterval(timerTick, 1000 / state.timeScale);
            playIcon.style.display = 'none';
            pauseIcon.style.display = 'block';
            toggleAmbientSound(true);
        }

        function pauseTimer() {
            state.isRunning = false;
            if(state.timerId) {
                clearInterval(state.timerId);
                state.timerId = null;
            }
            playIcon.style.display = 'block';
            pauseIcon.style.display = 'none';
            toggleAmbientSound(false);
            try {
                if (Tone.Transport.state === 'started') Tone.Transport.pause();
            } catch (e) { console.warn('Error pausing Transport', e); }
        }

        async function resetTimer() {
            pauseTimer();
            if (zombieModeState.active) {
                endZombieMode(false);
            }
            if (!currentGameState.inMultiplayer || currentGameState.mode !== 'cooperative') {
                clearGrove();
            }
            changeSpeed(1);
            state.pomodoroCount = 0;
            await switchMode('focus');
        }

        // --- 3D FOREST LOGIC ---
        // ===== VALIDACIÓN ADICIONAL EN getHeightAt =====
        // Reemplaza tu función getHeightAt con esta versión más segura:
        function getHeightAt(x, y) {
            const floorSize = 200;
            // Clamp a los límites del mapa
            if (Math.abs(x) > floorSize / 2 || Math.abs(y) > floorSize / 2) {
                return 10; // Altura por defecto fuera del mapa
            }
            const detailScale = 0.1;
            const peakHeight = 20;
            let height = 0;
            height += noise.noise2D(x * detailScale * 0.5, y * detailScale * 0.5) * 0.5;
            height += noise.noise2D(x * detailScale * 1.5, y * detailScale * 1.5) * 0.25;
            height += noise.noise2D(x * detailScale * 4, y * detailScale * 4) * 0.1;
            height = (height + 1) / 2;
            height = Math.pow(height, 1.5);

            const yNormalized = (y + floorSize / 2) / floorSize;
            const slopeHeight = peakHeight * Math.pow(yNormalized, 2);
            
            return height * peakHeight * 0.5 + slopeHeight;
        }


        function addVegetation() {
            shrubsGroup.clear();
            flowersGroup.clear();

            const bushGeometry = new THREE.SphereGeometry(1.2, 8, 8);
            const bushMaterial = new THREE.MeshStandardMaterial({ color: 0x2E7D32, roughness: 1 });
            for (let i = 0; i < 200; i++) {
                const bush = new THREE.Mesh(bushGeometry, bushMaterial.clone());
                bush.material.color.setHSL(0.33 + Math.random() * 0.05, 0.6, 0.3 + Math.random() * 0.2);

                const x = (Math.random() - 0.5) * 180;
                const z = (Math.random() - 0.5) * 180;
                const height = getHeightAt(x, -z); 
                
                if (height > 0.2) { 
                    bush.position.set(x, height + 0.5, z);
                    bush.castShadow = true;
                    shrubsGroup.add(bush);
                }
            }

            const petalColors = [0xff4d6d, 0xffd60a, 0x8ac926, 0x00b4d8, 0xffb5e8];
            const stemMaterial = new THREE.MeshStandardMaterial({ color: 0x388e3c });
            for (let i = 0; i < 400; i++) {
                const stemGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.5);
                const stem = new THREE.Mesh(stemGeometry, stemMaterial);
                const flower = new THREE.Group();

                const petalGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                const petalMaterial = new THREE.MeshStandardMaterial({ color: petalColors[Math.floor(Math.random() * petalColors.length)] });
                const petal = new THREE.Mesh(petalGeometry, petalMaterial);
                petal.position.y = 0.3;
                flower.add(stem);
                flower.add(petal);

                const x = (Math.random() - 0.5) * 180;
                const z = (Math.random() - 0.5) * 180;
                const height = getHeightAt(x, -z); 
                
                if (height > 0.2) {
                    flower.position.set(x, height + 0.25, z);
                    flower.rotation.y = Math.random() * Math.PI * 2;
                    flowersGroup.add(flower);
                }
            }
        }

        function createPineTree() {
            const tree = new THREE.Group();
            tree.userData.treeType = 'pine';
            const trunkHeight = 5 + (Math.random() - 0.5) * 2;
            const trunkGeo = new THREE.CylinderGeometry(0.4, 0.6, trunkHeight, 8); // Wider trunk
            trunkGeo.translate(0, trunkHeight / 2, 0);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x4a2e23 });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.castShadow = true;
            tree.add(trunk);
            
            const leafLevels = 3;
            for (let i = 0; i < leafLevels; i++) {
                const leafRadius = 2 - i * 0.5;
                const leafHeight = 2.5 - i * 0.5;
                const leafGeo = new THREE.ConeGeometry(leafRadius, leafHeight, 8);
                const leafMat = new THREE.MeshStandardMaterial({ color: 0x228b22 });
                leafMat.color.setHSL(0.3, 0.6, 0.3 + Math.random() * 0.1);
                const leaves = new THREE.Mesh(leafGeo, leafMat);
                leaves.position.y = trunkHeight + i * 1.0 - 1 + leafHeight/2;
                leaves.castShadow = true;
                tree.add(leaves);
            }
            return tree;
        }

        function createBroadleafTree() {
            const tree = new THREE.Group();
            tree.userData.treeType = 'broadleaf';
            const trunkHeight = 4 + Math.random() * 3;
            const trunkGeo = new THREE.CylinderGeometry(0.5, 0.6, trunkHeight, 8); // Wider trunk
            trunkGeo.translate(0, trunkHeight / 2, 0);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x6a4e43 });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.castShadow = true;
            tree.add(trunk);

            const crownGeo = new THREE.SphereGeometry(2.5, 8, 6);
            const crownMat = new THREE.MeshStandardMaterial({ color: 0x3a9940 });
            crownMat.color.setHSL(0.35, 0.5, 0.4 + Math.random() * 0.1);
            const crown = new THREE.Mesh(crownGeo, crownMat);
            crown.position.y = trunkHeight + 1.5;
            crown.scale.y = 0.8;
            crown.castShadow = true;
            tree.add(crown);

            return tree;
        }

        function createSpecialTree() {
            const tree = new THREE.Group();
             tree.userData.treeType = 'special';
            const trunkHeight = 5 + (Math.random() - 0.5) * 2;
            const trunkGeo = new THREE.CylinderGeometry(0.4, 0.5, trunkHeight, 8); // Wider trunk
            trunkGeo.translate(0, trunkHeight / 2, 0);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x4f3a30 });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.castShadow = true;
            tree.add(trunk);
            
            const leafGeo = new THREE.SphereGeometry(0.5, 6, 4);
            const leafBaseColor = new THREE.Color(0xffc2d1);

            for (let i = 0; i < 20; i++) {
                const leafMat = new THREE.MeshStandardMaterial({ color: leafBaseColor });
                leafMat.color.offsetHSL(0, (Math.random() - 0.5) * 0.2, (Math.random() - 0.5) * 0.1);
                const leaf = new THREE.Mesh(leafGeo, leafMat);
                
                const radius = Math.random() * 2.5;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);

                leaf.position.set(
                    radius * Math.sin(phi) * Math.cos(theta),
                    trunkHeight + (radius * Math.cos(phi)) * 0.7,
                    radius * Math.sin(phi) * Math.sin(theta)
                );
                
                leaf.castShadow = true;
                tree.add(leaf);
            }
            
            return tree;
        }

        function createTree(type = 'random') {
             if (type === 'random') {
                 const treeType = Math.random();
                 if (treeType < 0.6) return createPineTree();
                 return createBroadleafTree();
             }
             if(type === 'pine') return createPineTree();
             if(type === 'broadleaf') return createBroadleafTree();
             if(type === 'special') return createSpecialTree();
        }
        
        function clearGrove() {
            grove.forEach(tree => {
                scene.remove(tree);
                tree.traverse(object => {
                    if (object.isMesh) {
                        if (object.geometry) object.geometry.dispose();
                        if (object.material) {
                            if (Array.isArray(object.material)) {
                                object.material.forEach(material => material.dispose());
                            } else {
                                object.material.dispose();
                            }
                        }
                    }
                });
            });
            grove = [];
        }
        
        async function growATree({ isSpecial = false, taskId = null, isPomodoroCompletion = false } = {}) {
            
            const spawnRange = 190; // El tamaño del suelo es 200, dejamos un pequeño margen
            const x = (Math.random() - 0.5) * spawnRange;
            const z = (Math.random() - 0.5) * spawnRange;
            const y = getHeightAt(x,-z);

            if (y <= 0.2) return; // Don't grow tree if position is invalid

            const treeType = isSpecial ? 'special' : (Math.random() < 0.6 ? 'pine' : 'broadleaf');
            const baseScale = 1.0 + (Math.random() - 0.5) * 0.4;
            const targetScale = isSpecial ? baseScale * 1.15 : baseScale;

            const treeData = {
                type: treeType,
                position: { x, y, z },
                scale: targetScale,
                taskId: taskId,
                owner: userId,
                id: THREE.MathUtils.generateUUID(),
                isPomodoro: isPomodoroCompletion
            };
            
            if (currentGameState.inMultiplayer) {
                await updateFirestoreWithNewTree(treeData);
            } else {
                addTreeToScene(treeData);
            }
        }
        
        function addTreeToScene(treeData) {
            // Avoid adding duplicate trees
            if (grove.some(tree => tree.userData.id === treeData.id)) return;
        
            const tree = createTree(treeData.type);
            
            if (treeData.taskId) {
                tree.userData.taskId = treeData.taskId;
            }
            tree.userData.id = treeData.id;
            
            tree.position.set(treeData.position.x, treeData.position.y, treeData.position.z);
            tree.scale.set(0.01, 0.01, 0.01);
            tree.userData.isGrowing = true;
            tree.userData.targetScale = treeData.scale;
            
            grove.push(tree);
            scene.add(tree);
        }

        // --- SPEED CONTROLS ---
        function changeSpeed(newSpeed) {
            state.timeScale = newSpeed;

            document.querySelectorAll('#speed-controls .speed-button').forEach(btn => btn.classList.remove('active'));
            
            const activeBtn = document.querySelector(`#speed-controls .speed-button[data-speed="${newSpeed}"]`);
            if(activeBtn) activeBtn.classList.add('active');

            speedToggleBtn.textContent = `x${newSpeed}`;


            if (state.isRunning) {
                pauseTimer();
                startTimer();
            }
        }

        // --- BIOME/THEME SELECTOR ---
        const biomes = [
             { name: 'Forest', zenith: 0x87ceeb, horizon: 0xe0f2ff, ambient: 0xcccccc, sun: 0xffffff, sunColor: 0xFDB813 },
             { name: 'Desert', zenith: 0xfab1a0, horizon: 0xffd3b6, ambient: 0xaaaaaa, sun: 0xfff5e1, sunColor: 0xFDB813 },
             { name: 'Night', zenith: 0x0c0a1c, horizon: 0x2c3e50, ambient: 0x404060, sun: 0x606080, sunColor: 0xaaaaff }
        ];
        let currentBiomeIndex = -1;

        async function changeBiome(index) {
            if(index !== undefined) {
                 currentBiomeIndex = index - 1;
            }
            currentBiomeIndex = (currentBiomeIndex + 1) % biomes.length;
            const biome = biomes[currentBiomeIndex];
            
            skybox.material.uniforms.topColor.value.set(biome.zenith);
            skybox.material.uniforms.bottomColor.value.set(biome.horizon);
            sunMesh.material.color.set(biome.sunColor);
            
            scene.traverse(obj => { if(obj.isAmbientLight) obj.color.set(biome.ambient); });
            sunLight.color.set(biome.sun);

             if (currentGameState.inMultiplayer && currentGameState.isHost) {
                const gameRef = doc(db, `artifacts/${appId}/public/data/games`, currentGameState.gameId);
                await updateDoc(gameRef, { biomeIndex: currentBiomeIndex });
            }
        }

        // --- AUDIO ---
        let soundSources = {};
        let notificationSynth;
        let currentSound = 'mute';
        let isAudioReady = false;

        function initAudio() {
            const masterGain = new Tone.Gain(1).toDestination();
            const rainSynth = new Tone.NoiseSynth({ noise: { type: "brown" }, envelope: { attack: 0.01, sustain: 1 }, volume: -12 }).toDestination();
            soundSources.rain = {
                start: () => { if (rainSynth.state !== 'started') rainSynth.triggerAttack(); },
                stop: () => { rainSynth.triggerRelease(); }
            };
            
            const whiteSynth = new Tone.NoiseSynth({ noise: { type: "white" }, envelope: { attack: 0.01, sustain: 1 }, volume: -24 }).toDestination();
            soundSources.white_noise = {
                start: () => { if (whiteSynth.state !== 'started') whiteSynth.triggerAttack(); },
                stop: () => { whiteSynth.triggerRelease(); }
            };

            notificationSynth = new Tone.Synth({
                oscillator: { type: 'sine' },
                envelope: { attack: 0.005, decay: 0.1, sustain: 0.3, release: 1 },
                volume: -10
            }).toDestination();

            // --- NEW SOUND EFFECTS ---
            soundSources.shot_pistol = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.05 }, volume: -11.5 }).toDestination();
            soundSources.shot_rifle = new Tone.NoiseSynth({ noise: { type: 'pink' }, envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 }, volume: -9.5 }).toDestination();
            soundSources.shot_shotgun = new Tone.NoiseSynth({ noise: { type: 'brown' }, envelope: { attack: 0.01, decay: 0.3, sustain: 0, release: 0.2 }, volume: -6.5 }).toDestination();
            soundSources.player_hit = new Tone.FMSynth({ harmonicity: 0.5, modulationIndex: 10, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.1 }, volume: -5 }).toDestination();
            soundSources.hit_marker = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.005, decay: 0.05, sustain: 0, release: 0.1 }, volume: -15 }).toDestination();

            
            // Sound Pools for Zombies to prevent audio scheduling errors
            const ZOMBIE_DEATH_POOL_SIZE = 4;
            soundSources.zombie_deaths = [];
            for(let i=0; i<ZOMBIE_DEATH_POOL_SIZE; i++){
                soundSources.zombie_deaths.push(new Tone.FMSynth({ harmonicity: 0.2, modulationIndex: 20, envelope: { attack: 0.01, decay: 0.5, sustain: 0, release: 0.4 }, volume: -8 }).toDestination());
            }
            soundSources.zombie_death_index = 0;

            const ZOMBIE_STEP_POOL_SIZE = 8;
            soundSources.zombie_steps = [];
            for (let i = 0; i < ZOMBIE_STEP_POOL_SIZE; i++) {
                 soundSources.zombie_steps.push(new Tone.MembraneSynth({ pitchDecay: 0.01, octaves: 2, envelope: { attack: 0.001, decay: 0.1, sustain: 0 }, volume: -15 }).toDestination());
            }
            soundSources.zombie_step_index = 0;

            const ZOMBIE_GROWL_POOL_SIZE = 5;
            soundSources.zombie_growls = [];
            for (let i = 0; i < ZOMBIE_GROWL_POOL_SIZE; i++) {
                soundSources.zombie_growls.push(new Tone.AMSynth({
                    harmonicity: 0.8 + Math.random() * 0.4,
                    envelope: { attack: 0.1, decay: 0.5, sustain: 0.2, release: 0.5 },
                    modulation: { type: "sawtooth" },
                    modulationEnvelope: { attack: 0.01, decay: 0.2, sustain: 0.3, release: 0.1 },
                    volume: -10
                }).toDestination());
            }
            soundSources.zombie_growl_index = 0;


            soundSources._internal = { masterGain };
            updateVolume();
        }

        async function startAudioContext() {
            if (isAudioReady) return;
            await Tone.start();
            if (Tone.Transport.state !== 'started') Tone.Transport.start();
            isAudioReady = true;
            console.log("Audio context + Transport started.");
            updateVolume();
        }

        function stopAllAmbientSounds() {
            if (!isAudioReady) return;
            Object.keys(soundSources).forEach(key => {
                if (key === '_internal' || !soundSources[key]) return;
                const src = soundSources[key];
                if (src && typeof src.stop === 'function') {
                    try { src.stop(); } catch (e) { /* ignore */ }
                }
            });
        }
        
        function playCurrentSound() {
            if (!isAudioReady) return;
            stopAllAmbientSounds();
            const src = soundSources[currentSound];
            if (src && typeof src.start === 'function') {
                try { src.start(); } catch (e) { console.warn('Error starting sound', e); }
            }
        }
        
        function toggleAmbientSound(play) {
             if (play) {
                if (Tone.Transport.state !== 'started') Tone.Transport.start();
                playCurrentSound();
            } else {
                stopAllAmbientSounds();
                if (Tone.Transport.state === 'started') Tone.Transport.pause();
            }
        }

        function updateVolume(volumeValue) {
            const v = (typeof volumeValue === 'number') ? volumeValue : (document.getElementById ? parseFloat(document.getElementById('volume-slider')?.value ?? 50) : 50);
            const dB = -40 + (v / 100) * 40;
            if (isAudioReady) Tone.Destination.volume.value = dB;

            if (soundSources.forest && typeof soundSources.forest.setVolume === 'function') soundSources.forest.setVolume(v);
            if (soundSources.rain && typeof soundSources.rain.setVolume === 'function') soundSources.rain.setVolume(-12 + (v - 50) * 0.2);
            if (soundSources.white_noise && typeof soundSources.white_noise.setVolume === 'function') soundSources.white_noise.setVolume(-24 + (v - 50) * 0.2);
        }

        function playNotification() {
            if (!isAudioReady) return;
            notificationSynth.triggerAttackRelease("C5", "8n", Tone.now());
            notificationSynth.triggerAttackRelease("G5", "8n", Tone.now() + 0.2);
        }

        // --- TASK LIST & TRANSLATIONS---
        let tasks = [];
        const translations = {
             es: {
                 aiTutorTitle: "✨ Tutor IA",
                 aiTutorDescription: "¿Atascado en un problema? Descríbelo y la IA te dará una explicación simple.",
                 aiTutorPlaceholder: "Ej: ¿Por qué el cielo es azul?",
                 aiTutorGenerateBtn: "Explicar Concepto",
                 aiTutorLoading: "Pensando...",
                 todoTitle: "Lista de Tareas",
                 todoPlaceholder: "Añadir nueva tarea...",
                 settingsTitle: "Configuración",
                 focusLabel: "Enfoque",
                 shortBreakLabel: "Descanso Corto",
                 longBreakLabel: "Descanso Largo",
                 multiplayer: "Multijugador",
                 biome: "Bioma",
                 music: "Música",
                 language: "Idioma",
                 fullscreen: "Pantalla Completa",
                 createGame: "Crear Partida",
                 joinGame: "Unirse a Partida",
                 selectMode: "Seleccionar Modo",
                 cooperativeMode: "Cooperativo",
                 versusMode: "Lucha",
                 back: "Volver",
                 waitingForPlayer: "Esperando jugador...",
                 shareCode: "Comparte este código con un amigo:",
                 copied: "¡Copiado!",
                 enterCode: "Introduce el código de la partida",
                 join: "Unirse",
                 host: "Anfitrión",
                 guest: "Invitado",
                 saveLoadGame: "Guardar/Cargar Partida",
                 saveLoadDesc: "Exporta el estado de tu partida multijugador para continuarla más tarde.",
                 exportGame: "Exportar Partida",
                 importGame: "Importar Partida (Anfitrión)",
                 zombieRound: "Ronda:",
                 zombieKills: "Bajas:"
             },
             en: {
                 aiTutorTitle: "✨ AI Tutor",
                 aiTutorDescription: "Stuck on a problem? Describe it and the AI will give you a simple explanation.",
                 aiTutorPlaceholder: "E.g., Why is the sky blue?",
                 aiTutorGenerateBtn: "Explain Concept",
                 aiTutorLoading: "Thinking...",
                 todoTitle: "To-Do List",
                 todoPlaceholder: "Add a new task...",
                 settingsTitle: "Settings",
                 focusLabel: "Focus",
                 shortBreakLabel: "Short Break",
                 longBreakLabel: "Long Break",
                 multiplayer: "Multiplayer",
                 biome: "Biome",
                 music: "Music",
                 language: "Language",
                 fullscreen: "Fullscreen",
                 createGame: "Create Game",
                 joinGame: "Join Game",
                 selectMode: "Select Mode",
                 cooperativeMode: "Cooperative",
                 versusMode: "Versus",
                 back: "Back",
                 waitingForPlayer: "Waiting for player...",
                 shareCode: "Share this code with a friend:",
                 copied: "Copied!",
                 enterCode: "Enter the game code",
                 join: "Join",
                 host: "Host",
                 guest: "Guest",
                 saveLoadGame: "Save/Load Game",
                 saveLoadDesc: "Export your multiplayer game state to continue it later.",
                 exportGame: "Export Game",
                 importGame: "Import Game (Host)",
                 zombieRound: "Round:",
                 zombieKills: "Kills:"
             },
             fr: { // (Añadir más traducciones si es necesario)
                 aiTutorTitle: "✨ Tuteur IA",
                 aiTutorDescription: "Bloqué sur un problème ? Décrivez-le et l'IA vous donnera une explication simple.",
                 aiTutorPlaceholder: "Ex : Pourquoi le ciel est-il bleu ?",
                 aiTutorGenerateBtn: "Expliquer le Concept",
                 aiTutorLoading: "Réflexion...",
                 todoTitle: "Liste de Tâches",
                 todoPlaceholder: "Ajouter une nouvelle tâche...",
                 settingsTitle: "Paramètres",
                 focusLabel: "Concentration",
                 shortBreakLabel: "Pause Courte",
                 longBreakLabel: "Pause Longue",
                 multiplayer: "Multijoueur",
                 biome: "Biome",
                 music: "Musique",
                 language: "Langue",
                 fullscreen: "Plein écran",
                 zombieRound: "Manche:",
                 zombieKills: "Éliminations:"
             },
             zh: {
                 aiTutorTitle: "✨ AI导师",
                 aiTutorDescription: "遇到问题了吗？描述一下，AI会给你一个简单的解释让你继续前进。",
                 aiTutorPlaceholder: "例如：天空为什么是蓝色的？",
                 aiTutorGenerateBtn: "解释概念",
                 aiTutorLoading: "思考中...",
                 todoTitle: "待办事项",
                 todoPlaceholder: "添加新任务...",
                 settingsTitle: "设置",
                 focusLabel: "专注",
                 shortBreakLabel: "短暂休息",
                 longBreakLabel: "长时间休息",
                 multiplayer: "多人游戏",
                 biome: "生物群系",
                 music: "音乐",
                 language: "语言",
                 fullscreen: "全屏",
                 zombieRound: "回合:",
                 zombieKills: "击杀:"
             },
             hi: {
                 aiTutorTitle: "✨ एआई ट्यूटर",
                 aiTutorDescription: "किसी समस्या में फंस गए हैं? इसका वर्णन करें और एआई आपको एक सरल व्याख्या देगा।",
                 aiTutorPlaceholder: "जैसे: आकाश नीला क्यों है?",
                 aiTutorGenerateBtn: "अवधारणा समझाओ",
                 aiTutorLoading: "सोच रहा है...",
                 todoTitle: "कार्य सूची",
                 todoPlaceholder: "एक नया कार्य जोड़ें...",
                 settingsTitle: "समायोजन",
                 focusLabel: "केंद्र",
                 shortBreakLabel: "छोटा विराम",
                 longBreakLabel: "लंबा विराम",
                 multiplayer: "मल्टीप्लेयर",
                 biome: "बायोम",
                 music: "संगीत",
                 language: "भाषा",
                 fullscreen: "पूर्ण स्क्रीन",
                 zombieRound: "राउंड:",
                 zombieKills: "हत्या:"
             }
        };

        function applyLanguage(lang) {
            state.currentLang = lang;
            document.documentElement.lang = lang;
            localStorage.setItem('language', lang);
            
            const code = {es: 'es', en: 'us', fr: 'fr', zh: 'cn', hi: 'in'}[lang] || 'es';
            languageBtn.style.backgroundImage = `url('https://flagcdn.com/w40/${code}.png')`;

            document.querySelectorAll('[data-translate-key]').forEach(el => {
                const key = el.dataset.translateKey;
                if(translations[lang] && translations[lang][key]) {
                    const translation = translations[lang][key];
                    if (el.placeholder !== undefined && (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA')) {
                        el.placeholder = translation;
                    } else if (el.title !== undefined && el.tagName === 'BUTTON') {
                        el.title = translation;
                    }
                    else {
                        el.textContent = translation;
                    }
                }
            });
        }


        function renderTasks() {
            taskList.innerHTML = '';
            tasks.forEach((task) => {
                const li = document.createElement('li');
                li.dataset.id = task.id;
                
                li.innerHTML = `
                    <input type="checkbox" ${task.completed ? 'checked' : ''}>
                    <span class="task-text ${task.completed ? 'completed' : ''}">${task.text}</span>
                    <button class="delete-task">&times;</button>
                `;
                taskList.appendChild(li);
            });
        }

        function saveTasks() {
            localStorage.setItem('focusGroveTasks', JSON.stringify(tasks));
        }

        function loadTasks() {
            const storedTasks = localStorage.getItem('focusGroveTasks');
            if (storedTasks) {
                tasks = JSON.parse(storedTasks);
                renderTasks();
                // We will let the multiplayer sync handle showing initial trees
                if(!currentGameState.inMultiplayer) {
                    tasks.forEach(task => {
                        if (task.completed) {
                            growATree({ isSpecial: true, taskId: task.id });
                        }
                    });
                }
            }
        }
        
        function addTask() {
            const text = newTaskInput.value.trim();
            if (text) {
                 tasks.push({ id: Date.now(), text, completed: false });
                newTaskInput.value = '';
                saveTasks();
                renderTasks();
            }
        }
        
        function toggleTask(id) {
            const task = tasks.find(t => t.id === id);
            if (task) {
                task.completed = !task.completed;
                
                if (task.completed) {
                    growATree({ isSpecial: true, taskId: id });
                } else {
                    removeTaskTree(id);
                }

                saveTasks();
                renderTasks();
            }
        }
        
        function deleteTask(id) {
            const task = tasks.find(t => t.id === id);
            if (task && task.completed) {
                removeTaskTree(id);
            }
            tasks = tasks.filter(t => t.id !== id);
            saveTasks();
            renderTasks();
        }
        
        async function removeTaskTree(taskId) {
            if (currentGameState.inMultiplayer) {
                const gameRef = doc(db, `artifacts/${appId}/public/data/games`, currentGameState.gameId);
                const gameSnap = await getDoc(gameRef);
                if (!gameSnap.exists()) return;

                const gameData = gameSnap.data();
                let treeToRemove = null;

                if (currentGameState.mode === 'cooperative') {
                    treeToRemove = gameData.sharedTrees.find(t => t.taskId === taskId);
                    if (treeToRemove) {
                        await updateDoc(gameRef, { sharedTrees: arrayRemove(treeToRemove) });
                    }
                } else if (currentGameState.mode === 'versus') {
                    treeToRemove = gameData.players[userId]?.trees.find(t => t.taskId === taskId);
                    if (treeToRemove) {
                        await updateDoc(gameRef, { [`players.${userId}.trees`]: arrayRemove(treeToRemove) });
                    }
                }
            } else {
                const treeToRemove = grove.find(tree => tree.userData.taskId === taskId);
                if (treeToRemove) {
                    removeTreeObjectFromScene(treeToRemove);
                    grove = grove.filter(tree => tree.uuid !== treeToRemove.uuid);
                }
            }
        }


        function removeTreeObjectFromScene(treeObject) {
             scene.remove(treeObject);
            treeObject.traverse(object => {
                if (object.isMesh) {
                    if (object.geometry) object.geometry.dispose();
                    if (object.material) {
                        if (Array.isArray(object.material)) {
                            object.material.forEach(material => material.dispose());
                        } else {
                            object.material.dispose();
                        }
                    }
                }
            });
        }
        
        async function getTutorExplanation() {
            const userQuery = aiTutorPromptInput.value;
            const systemPrompt = "Eres un tutor amigable y experto. Tu objetivo es explicar conceptos difíciles de una manera muy simple y fácil de entender. Usa analogías y un lenguaje claro.";
            
            aiTutorLoading.classList.remove('hidden');
            aiTutorOutput.innerHTML = '';
            aiTutorGenerateBtn.disabled = true;

            const apiKey = "";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
            };

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) throw new Error(`API Error: ${response.status}`);
                const result = await response.json();
                const text = result.candidates?.[0]?.content?.parts?.[0]?.text;
                if (text) {
                    aiTutorOutput.innerHTML = text.split('\n').filter(p => p.trim()).map(p => `<p class="mb-2">${p}</p>`).join('');
                } else {
                    throw new Error("No text returned from API.");
                }
            } catch(error) {
                console.error("Gemini API error:", error);
                aiTutorOutput.innerHTML = `<p class="text-red-500">Error al obtener la explicación.</p>`;
            } finally {
                aiTutorLoading.classList.add('hidden');
                aiTutorGenerateBtn.disabled = false;
            }
        }

        // --- CREDIT LINE ---
        function addCreditLine() {
            if (document.getElementById('credit-line')) return;
            const credit = document.createElement('a');
            credit.id = 'credit-line';
            credit.textContent = 'Hecho por Daniel Terroba Alcala';
            credit.href = 'https://github.com/Mrdaniel7';
            credit.target = '_blank';
            credit.rel = 'noopener noreferrer';
            credit.style.position = 'fixed';
            credit.style.bottom = '10px';
            credit.style.right = '10px';
            credit.style.fontSize = '12px';
            credit.style.zIndex = '1001';
            credit.style.pointerEvents = 'auto'; // Make it clickable
            document.body.appendChild(credit);
        }
        
        // --- MULTIPLAYER LOGIC ---

        function generateGameId() {
            const ADJECTIVES = ['ROJO', 'VERDE', 'AZUL', 'GRAN', 'LEAL', 'VELOZ'];
            const NOUNS = ['LEON', 'TIGRE', 'SOL', 'LUNA', 'RIO', 'REY'];
            const adj = ADJECTIVES[Math.floor(Math.random() * ADJECTIVES.length)];
            const noun = NOUNS[Math.floor(Math.random() * NOUNS.length)];
            const num = Math.floor(Math.random() * 90) + 10;
            return `${adj}-${noun}-${num}`;
        }
        
        function showMultiplayerView(viewId) {
            [multiplayerInitialView, multiplayerHostView, multiplayerWaitingView, multiplayerJoinView].forEach(v => v.classList.add('hidden'));
            document.getElementById(viewId).classList.remove('hidden');
        }
        
        async function hostGame(mode, importedData = null) {
            if (!userId) {
                console.error("Authentication Error.");
                return;
            }
            const gameId = generateGameId();
            
            let initialData;
            if (importedData) {
                initialData = { ...importedData, gameId, hostId: userId, guestId: null, status: 'waiting' };
            } else {
                 initialData = {
                    gameId: gameId,
                    mode: mode,
                    status: 'waiting',
                    hostId: userId,
                    mapSeed: Math.random().toString(),
                    biomeIndex: Math.floor(Math.random() * biomes.length),
                    players: {
                        [userId]: { pomodoros: 0, trees: [], status: 'focus' }
                    },
                    duel: { status: 'inactive' }
                };
            }

            const gameRef = doc(db, `artifacts/${appId}/public/data/games`, gameId);
            await setDoc(gameRef, initialData);

            listenToGameChanges(gameId);
            currentGameState.inMultiplayer = true;
            currentGameState.isHost = true;
            currentGameState.gameId = gameId;
            currentGameState.mode = mode;
            
            gameCodeDisplay.textContent = gameId;
            showMultiplayerView('multiplayer-waiting');
        }

        async function joinGame(gameId) {
             if (!userId) {
                console.error("Authentication Error.");
                return;
            }
            const gameRef = doc(db, `artifacts/${appId}/public/data/games`, gameId);
            const gameSnap = await getDoc(gameRef);

            if (!gameSnap.exists()) {
                alert("Partida no encontrada.");
                return;
            }

            const gameData = gameSnap.data();

            // Rejoining logic
            if (gameData.players && gameData.players[userId]) {
                console.log("Rejoining game...");
                listenToGameChanges(gameId);
                currentGameState.inMultiplayer = true;
                currentGameState.isHost = gameData.hostId === userId;
                currentGameState.gameId = gameId;
                currentGameState.mode = gameData.mode;
                multiplayerModal.classList.remove('active');
                return;
            }
            
            const playerCount = Object.keys(gameData.players).length;

            if (gameData.mode === 'cooperative' && playerCount >= 5) {
                alert("Esta partida cooperativa ya está llena (5 jugadores).");
                return;
            }
            if (gameData.mode === 'versus' && playerCount >= 2) {
                alert("Esta partida de lucha ya está llena (2 jugadores).");
                return;
            }
            if (gameData.mode === 'versus' && gameData.status === 'active') {
                 alert("La partida ya ha comenzado o está llena.");
                 return;
            }

            await updateDoc(gameRef, {
                [`players.${userId}`]: { pomodoros: 0, trees: [], status: 'focus' }
            });

            // For versus mode, start the game when the second player joins
            if (gameData.mode === 'versus' && playerCount === 1) {
                await updateDoc(gameRef, { status: 'active' });
            }

            listenToGameChanges(gameId);
            currentGameState.inMultiplayer = true;
            currentGameState.isHost = false;
            currentGameState.gameId = gameId;
            currentGameState.mode = gameData.mode;
            multiplayerModal.classList.remove('active');
        }

        function listenToGameChanges(gameId) {
             if(currentGameState.unsubscribe) currentGameState.unsubscribe(); 
            
            localStorage.setItem('focusGroveLastGame', gameId);
            const gameRef = doc(db, `artifacts/${appId}/public/data/games`, gameId);
            
            currentGameState.unsubscribe = onSnapshot(gameRef, (doc) => {
                if (!doc.exists()) {
                    console.log("Game session ended.");
                    leaveGame();
                    return;
                }

                const gameData = doc.data();
                
                if (noise === undefined && gameData.mapSeed) {
                    init3D(gameData.mapSeed, gameData.biomeIndex);
                }

                currentGameState.playerCount = Object.keys(gameData.players).length;
                currentGameState.playerIds = Object.keys(gameData.players);


                if (currentGameState.isHost && gameData.status === 'active' && !multiplayerWaitingView.classList.contains('hidden')) {
                    multiplayerModal.classList.remove('active');
                }
                
                if (gameData.mode === 'cooperative') {
                    syncCoopGrove(gameData.sharedTrees || []);
                    versusScoreboard.classList.add('hidden');
                } else if (gameData.mode === 'versus') {
                    syncVersusState(gameData);
                    syncDuelState(gameData); // New function for minigame sync
                }
            });
        }
        
        function syncCoopGrove(treesFromDb) {
            treesFromDb.forEach(treeData => {
                if (!grove.some(localTree => localTree.userData.id === treeData.id)) {
                    addTreeToScene(treeData);
                }
            });

            grove.slice().forEach(localTree => {
                if (!treesFromDb.some(dbTree => dbTree.id === localTree.userData.id)) {
                    removeTreeObjectFromScene(localTree);
                    grove = grove.filter(t => t.uuid !== localTree.uuid);
                }
            });
        }
        
        function syncVersusState(gameData) {
            if (duelState.active) {
                versusScoreboard.classList.add('hidden');
                return;
            }
            versusScoreboard.classList.remove('hidden');
            const playersData = gameData.players;
            
            const myData = playersData[userId];
            const myTreesFromDb = myData?.trees || [];

            myTreesFromDb.forEach(treeData => {
                if (!grove.some(localTree => localTree.userData.id === treeData.id)) {
                    addTreeToScene(treeData);
                }
            });

            grove.slice().forEach(localTree => {
                if (!myTreesFromDb.some(dbTree => dbTree.id === localTree.userData.id)) {
                    removeTreeObjectFromScene(localTree);
                    grove = grove.filter(t => t.uuid !== localTree.uuid);
                }
            });
            
            const hostId = gameData.hostId;
            const guestId = Object.keys(playersData).find(id => id !== hostId);

            const hostData = playersData[hostId];
            const guestData = guestId ? playersData[guestId] : null;

            // Update host score
            document.querySelector('#player1-score .pomodoro-count').textContent = `${hostData ? hostData.pomodoros : 0} 🍅`;
            document.querySelector('#player1-score .tree-count').textContent = `${hostData && hostData.trees ? hostData.trees.length : 0} 🌳`;
            
            // Update guest score
            document.querySelector('#player2-score .pomodoro-count').textContent = `${guestData ? guestData.pomodoros : 0} 🍅`;
            document.querySelector('#player2-score .tree-count').textContent = `${guestData && guestData.trees ? guestData.trees.length : 0} 🌳`;

            const hostName = translations[state.currentLang].host;
            const guestName = translations[state.currentLang].guest;

            document.querySelector('#player1-score h4').textContent = (userId === hostId) ? `Tú (${hostName})` : hostName;
            document.querySelector('#player2-score h4').textContent = (userId === guestId) ? `Tú (${guestName})` : (guestId ? guestName : '...');
            
            // Check if both players are on break to show duel button
            const p1Status = hostData ? hostData.status : null;
            const p2Status = guestData ? guestData.status : null;

            if ((p1Status === 'shortBreak' || p1Status === 'longBreak') && 
                (p2Status === 'shortBreak' || p2Status === 'longBreak')) {
                duelModeBtn.textContent = '⚔️ ¡Duelo! ⚔️';
                duelModeBtn.classList.remove('hidden');
                 duelModeBtn.disabled = !currentGameState.isHost;
            } else {
                duelModeBtn.classList.add('hidden');
            }
        }


        async function updateFirestoreWithNewTree(treeData) {
            const gameRef = doc(db, `artifacts/${appId}/public/data/games`, currentGameState.gameId);
            
            if (currentGameState.mode === 'cooperative') {
                await updateDoc(gameRef, { sharedTrees: arrayUnion(treeData) });
            } else if (currentGameState.mode === 'versus') {
                const updates = {
                    [`players.${userId}.trees`]: arrayUnion(treeData)
                };
                if (treeData.isPomodoro) {
                    updates[`players.${userId}.pomodoros`] = increment(1);
                }
                await updateDoc(gameRef, updates);
            }
        }
        
        function leaveGame() {
            if (currentGameState.unsubscribe) {
                currentGameState.unsubscribe();
            }
             currentGameState = {
                inMultiplayer: false,
                isHost: false,
                gameId: null,
                mode: null,
                unsubscribe: null,
                playerCount: 1,
            };
            localStorage.removeItem('focusGroveLastGame');
            versusScoreboard.classList.add('hidden');
            clearGrove();
            resetTimer();
        }

        async function exportGame() {
            if (!currentGameState.inMultiplayer) {
                alert("Debes estar en una partida multijugador para exportarla.");
                return;
            }
            const gameRef = doc(db, `artifacts/${appId}/public/data/games`, currentGameState.gameId);
            const gameSnap = await getDoc(gameRef);
            if (gameSnap.exists()) {
                const data = JSON.stringify(gameSnap.data(), null, 2);
                const blob = new Blob([data], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `focus-grove-game-${currentGameState.gameId}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }
        }

        function importGame(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const importedData = JSON.parse(e.target.result);
                    if(importedData.mode && importedData.players) {
                        leaveGame();
                        await hostGame(importedData.mode, importedData);
                    } else {
                        alert("Archivo JSON inválido.");
                    }
                } catch (error) {
                    console.error("Error al importar la partida:", error);
                    alert("Error al leer el archivo JSON.");
                }
            };
            reader.readAsText(file);
        }
        
        function hideUI() {
            document.body.classList.add('ui-hidden');
        }

        function showUI() {
            document.body.classList.remove('ui-hidden');
            if(inactivityTimer) clearTimeout(inactivityTimer);
            inactivityTimer = setTimeout(hideUI, 10000); // 10 seconds
        }

        // --- SINGLE PLAYER DUEL TEST ---
        function updateSinglePlayerDuelButtonVisibility() {
            if (!currentGameState.inMultiplayer && singlePlayerDuelEnabled) {
                if (state.mode === 'shortBreak' || state.mode === 'longBreak') {
                    duelModeBtn.textContent = '🧟‍♂️ Modo Zombi 🧟‍♂️';
                    duelModeBtn.classList.remove('hidden');
                } else {
                    duelModeBtn.classList.add('hidden');
                }
            } else if (currentGameState.inMultiplayer && currentGameState.mode === 'versus') {
                const gameRef = doc(db, `artifacts/${appId}/public/data/games`, currentGameState.gameId);
                getDoc(gameRef).then(docSnap => {
                    if (docSnap.exists()) {
                        const gameData = docSnap.data();
                        const playersData = gameData.players;
                        const hostId = gameData.hostId;
                        const guestId = Object.keys(playersData).find(id => id !== hostId);
                        const p1Status = playersData[hostId]?.status;
                        const p2Status = guestId ? playersData[guestId]?.status : null;

                        if ((p1Status === 'shortBreak' || p1Status === 'longBreak') && 
                            (p2Status === 'shortBreak' || p2Status === 'longBreak')) {
                            duelModeBtn.textContent = '⚔️ ¡Duelo! ⚔️';
                            duelModeBtn.classList.remove('hidden');
                            duelModeBtn.disabled = !currentGameState.isHost;
                        } else {
                            duelModeBtn.classList.add('hidden');
                        }
                    }
                });
            } else {
                 duelModeBtn.classList.add('hidden');
            }
        }

        // --- SHOOTER MINIGAME LOGIC ---

        function playRemoteShotSound(playerId) {
            if (!isAudioReady || !duelState.players[playerId]) return;
            
            const playerClass = duelState.players[playerId].class;
            switch (playerClass) {
                case 'scout':
                    soundSources.shot_pistol.triggerAttack();
                    break;
                case 'soldier':
                    soundSources.shot_rifle.triggerAttack();
                    break;
                case 'tank':
                    soundSources.shot_shotgun.triggerAttack();
                    break;
            }
        }

        function syncDuelState(gameData) {
            const newDuelStatus = gameData.duel?.status || 'inactive';

            // Transition from inactive to selecting
            if (duelState.status === 'inactive' && newDuelStatus === 'selecting') {
                duelState.status = 'selecting';
                duelModeBtn.classList.add('hidden');
                classSelectionModal.classList.add('active');
            }

            // Update class selection view
            if (newDuelStatus === 'selecting') {
                const opponentId = currentGameState.playerIds.find(id => id !== userId);
                if (opponentId) {
                    const opponentClass = gameData.duel?.players?.[opponentId]?.class;
                    const myClass = gameData.duel?.players?.[userId]?.class;
                    if(myClass && !opponentClass) {
                        document.getElementById('waiting-for-opponent-class').classList.remove('hidden');
                    }
                }
            }
            
            // Transition from selecting to active
            if (duelState.status === 'selecting' && newDuelStatus === 'active') {
                duelState.status = 'active';
                const duelData = gameData.duel;
                classSelectionModal.classList.remove('active');
                versusScoreboard.classList.add('hidden');
            
                // Initialize players with checks and default values
                for (const id in duelData.players) {
                    const playerData = duelData.players[id] || {};
                    const cls = playerData.class || 'soldier'; // fallback if class is missing
                    duelState.players[id] = {
                        class: cls,
                        health: (CLASS_STATS[cls] && CLASS_STATS[cls].maxHealth) ? CLASS_STATS[cls].maxHealth : 100,
                        score: playerData.score || 0,
                    };
                }
            
                // Start scene with protection to prevent any errors from breaking the main loop
                try {
                    startDuelScene(gameData);
                } catch (err) {
                    console.error("Error starting duel scene:", err);
                    // Revert state so the app doesn't hang
                    duelState.status = 'inactive';
                    duelState.active = false;
                    // Restore basic UI
                    document.querySelectorAll('.controls').forEach(c => c.classList.remove('hidden'));
                    updateSinglePlayerDuelButtonVisibility();
                }
            }
            
            // Sync active game state (positions, health, etc.)
            if (newDuelStatus === 'active' && duelState.active) {
                const duelData = gameData.duel;
                for (const id in duelData.players) {
                    if (id !== userId && duelState.remotePlayer && duelState.remotePlayer.userData.targetPosition) { // Update remote player
                        const remoteData = duelData.players[id];
                        if (remoteData.position) {
                           duelState.remotePlayer.userData.targetPosition.set(remoteData.position.x, remoteData.position.y, remoteData.position.z);
                           duelState.remotePlayer.userData.targetRotationY = remoteData.rotationY;
                        }
                        duelState.players[id].health = remoteData.health;
                        duelState.players[id].score = remoteData.score;
                    } else if (id === userId && duelState.localPlayer) { // Update local player health if changed by opponent
                        const newHealth = duelData.players[id].health;
                        const oldHealth = duelState.localPlayer.health;
                        if (newHealth < oldHealth) {
                            const damageTaken = oldHealth - newHealth;
                            duelState.localPlayer.takeDamage(damageTaken);
                        } else {
                            duelState.localPlayer.health = newHealth;
                        }
                    }
                }
                updateDuelHud();

                 // Sync projectiles
                if (duelData.projectiles) {
                     duelData.projectiles.forEach(p => {
                         // Avoid creating a projectile we already know about
                         if (!duelState.projectiles.some(proj => proj.userData.id === p.id)) {
                             if (p.owner !== userId) { // Only spawn projectiles from the other player
                                 spawnProjectile(p, false);
                                 playRemoteShotSound(p.owner);
                             }
                         }
                     });
                }
            }

             // Transition from active to finished
            if (duelState.status === 'active' && newDuelStatus === 'finished') {
                endDuelScene(gameData);
            }
        }

        async function handleDuelButtonClick() {
            if (currentGameState.inMultiplayer && currentGameState.isHost) {
                const gameRef = doc(db, `artifacts/${appId}/public/data/games`, currentGameState.gameId);
                const initialDuelState = {
                    status: 'selecting',
                    players: {
                        [currentGameState.playerIds[0]]: { score: 0, health: 100, lastShot: 0 },
                        [currentGameState.playerIds[1]]: { score: 0, health: 100, lastShot: 0 }
                    },
                    projectiles: []
                };
                await updateDoc(gameRef, { duel: initialDuelState });
            } else if (singlePlayerDuelEnabled) {
                classSelectionModal.classList.add('active');
            }
        }
        
        async function handleClassSelection(e) {
            const card = e.target.closest('.class-card');
            if (!card) return;
            
            const className = card.dataset.class;

            if (currentGameState.inMultiplayer) {
                const gameRef = doc(db, `artifacts/${appId}/public/data/games`, currentGameState.gameId);
                await updateDoc(gameRef, { 
                    [`duel.players.${userId}.class`]: className,
                    [`duel.players.${userId}.health`]: CLASS_STATS[className].maxHealth
                });

                const gameSnap = await getDoc(gameRef);
                const duelData = gameSnap.data().duel;
                const playerIds = Object.keys(duelData.players);
                
                if(playerIds.length < 2) return;

                const p1Class = duelData.players[playerIds[0]]?.class;
                const p2Class = duelData.players[playerIds[1]]?.class;

                if (p1Class && p2Class) {
                    // Only host transitions the game state to active
                    if (currentGameState.isHost) {
                         await updateDoc(gameRef, { 'duel.status': 'active' });
                    }
                }

            } else if (singlePlayerDuelEnabled) {
                classSelectionModal.classList.remove('active');
                startZombieMode(className);
            }
        }
        
        function startDuelScene(gameData) {
            duelState.active = true;
            document.body.classList.add('duel-active');
            document.body.classList.remove('ui-hidden');

            // Hide normal UI, show duel UI
            document.querySelectorAll('.controls').forEach(c => c.classList.add('hidden'));
            timerDisplay.classList.add('timer-display-duel');
            duelHud.classList.remove('hidden');
            localPlayerDuelHud.classList.remove('hidden');
            duelModeBtn.classList.add('hidden'); // Ocultar el botón de duelo al iniciar

            if (!state.isRunning) {
                startTimer();
            }
            
            clearGrove(); // Clear trees for the duel
            addVegetation();

            const opponentId = currentGameState.playerIds.find(id => id !== userId);

            const myClass = (gameData.duel.players?.[userId]?.class) || 'soldier';
            const opponentClass = (gameData.duel.players?.[opponentId]?.class) || 'soldier';

            try {
                duelState.localPlayer = new PlayerController(true, myClass);
                
                const remotePlayerGroup = new THREE.Group();
                const bodyGeo = new THREE.CapsuleGeometry(0.5, 1, 4, 8);
                bodyGeo.translate(0, 0.5, 0);
                const bodyMat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
                const remoteBody = new THREE.Mesh(bodyGeo, bodyMat);
                remotePlayerGroup.add(remoteBody);

                const remoteWeapon = duelState.localPlayer.createWeaponMesh(opponentClass);
                remoteWeapon.position.set(0, 1.4, 0.4);
                remotePlayerGroup.add(remoteWeapon);

                scene.add(remotePlayerGroup);
                duelState.remotePlayer = remotePlayerGroup;
                duelState.remotePlayer.userData.targetPosition = new THREE.Vector3();
                duelState.remotePlayer.userData.targetRotationY = 0;

                duelState.localPlayer.respawn();
                enableShooterControls();
            } catch (err) {
                console.error("Failed to create PlayerControllers:", err);
                if (duelState.localPlayer && duelState.localPlayer.dispose) duelState.localPlayer.dispose();
                if (duelState.remotePlayer) scene.remove(duelState.remotePlayer);
                duelState.localPlayer = null;
                duelState.remotePlayer = null;
                duelState.active = false;
                duelState.status = 'inactive';
            }
        }

        async function endDuelScene(gameData) {
            if (!duelState.active) return; // Prevent multiple triggers
            
            duelState.active = false;
            duelState.status = 'finished';
            
            document.body.classList.remove('duel-active');
            disableShooterControls();

            // Clean up scene
            if (duelState.localPlayer) {
                duelState.localPlayer.dispose();
            }
             if (duelState.remotePlayer) scene.remove(duelState.remotePlayer);
            duelState.projectiles.forEach(p => scene.remove(p));
            duelState.projectiles = [];
            duelState.localPlayer = null;
            duelState.remotePlayer = null;

            // Show results
            duelHud.classList.add('hidden');
            localPlayerDuelHud.classList.add('hidden');
            timerDisplay.classList.remove('timer-display-duel');

            const duelData = gameData.duel;
            const myScore = duelData.players[userId].score;
            const opponentId = currentGameState.playerIds.find(id => id !== userId);
            const opponentScore = duelData.players[opponentId]?.score || 0;

            document.getElementById('final-duel-score').textContent = `${myScore} - ${opponentScore} Bajas`;
            if (myScore > opponentScore) {
                document.getElementById('duel-winner-text').textContent = "¡Has ganado!";
            } else if (opponentScore > myScore) {
                document.getElementById('duel-winner-text').textContent = "Has perdido...";
            } else {
                document.getElementById('duel-winner-text').textContent = "¡Es un empate!";
            }
            duelResultsModal.classList.add('active');
        }

        async function closeDuelResults() {
            duelResultsModal.classList.remove('active');
            // Only host resets the duel state in Firestore
            if (currentGameState.inMultiplayer) {
                if (currentGameState.isHost) {
                    const gameRef = doc(db, `artifacts/${appId}/public/data/games`, currentGameState.gameId);
                    await updateDoc(gameRef, { 'duel.status': 'inactive' });
                }
            }
             // Restore normal UI
            document.querySelectorAll('.controls').forEach(c => c.classList.remove('hidden'));
            if (currentGameState.inMultiplayer) {
                versusScoreboard.classList.remove('hidden');
            }
            // Switch back to focus mode, paused
            await switchMode('focus');
            pauseTimer();
        }
        
        function updateDuelHud() {
             if (!duelState.localPlayer) return;
             
             const myInfo = duelState.localPlayer;
             const myClassStats = myInfo.classStats;

             if(zombieModeState.active) {
                // In zombie mode, we only show local player health
                localPlayerHealthBar.style.width = `${(myInfo.health / myClassStats.maxHealth) * 100}%`;
                document.getElementById('local-player-name-hud').textContent = `Tú`;
             } else if (duelState.active) {
                // Duel mode logic
                const opponentId = currentGameState.playerIds.find(id => id !== userId);
                const opponentInfo = duelState.players[opponentId];
                if(!opponentInfo) return;

                duelScoreDisplay.textContent = `${duelState.players[userId].score} - ${opponentInfo.score}`;
                localPlayerHealthBar.style.width = `${(myInfo.health / myClassStats.maxHealth) * 100}%`;
                remotePlayerHealthBar.style.width = `${(opponentInfo.health / CLASS_STATS[opponentInfo.class].maxHealth) * 100}%`;
                document.getElementById('local-player-name-hud').textContent = `Tú (${duelState.players[userId].class})`;
                document.getElementById('remote-player-name-hud').textContent = `Oponente (${opponentInfo.class})`;
             }
        }
        
        // ===== FUNCIÓN enableShooterControls CORREGIDA =====
        function enableShooterControls() {
            orbitControls.enabled = false;
            
            const lockPointer = () => {
                pointerLockControls.lock();
            };
            canvas.addEventListener('click', lockPointer);
            
            const onUnlock = () => {
                 canvas.addEventListener('click', lockPointer);
            };
            pointerLockControls.addEventListener('unlock', onUnlock);

            // Initial lock
            pointerLockControls.lock();
        }

        function disableShooterControls() {
            orbitControls.enabled = true;
            pointerLockControls.unlock();
            camera.position.set(0, 20, 50);
            orbitControls.target.set(0,0,0);
        }

        async function spawnProjectile(data, isLocal) {
             const projectileGeo = new THREE.SphereGeometry(0.1, 8, 8);
             const projectileMat = new THREE.MeshBasicMaterial({ color: 0xffeb3b });
             const projectile = new THREE.Mesh(projectileGeo, projectileMat);
             
             projectile.position.copy(data.position);
             projectile.userData.velocity = new THREE.Vector3().copy(data.velocity);
             projectile.userData.owner = data.owner;
             projectile.userData.id = data.id;
             projectile.userData.range = data.range;
             projectile.userData.spawnTime = Date.now();
             projectile.userData.initialPosition = data.position;
             projectile.userData.originalData = data;
             
             scene.add(projectile);
             duelState.projectiles.push(projectile);

            if (isLocal && currentGameState.inMultiplayer) {
                const gameRef = doc(db, `artifacts/${appId}/public/data/games`, currentGameState.gameId);
                
                await updateDoc(gameRef, {
                    projectiles: arrayUnion(data)
                });
            }
        }
        
        const stuckCheckRaycaster = new THREE.Raycaster();
        function checkIfStuck() {
            if (!duelState.localPlayer || !duelState.active) return;

            const playerPosition = pointerLockControls.getObject().position;
            const directions = [
                new THREE.Vector3(1, 0, 0), new THREE.Vector3(-1, 0, 0),
                new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1),
                new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, -1, 0)
            ];
            let stuckCount = 0;
            const checkDistance = 1.0; // Check for collisions within 1 unit

            for (const direction of directions) {
                stuckCheckRaycaster.set(playerPosition, direction);
                stuckCheckRaycaster.far = checkDistance;
                const intersects = stuckCheckRaycaster.intersectObjects(grove, true);
                if (intersects.length > 0) {
                    stuckCount++;
                }
            }

            // If 4 or more rays hit something close, we're likely inside an object
            if (stuckCount >= 4) {
                console.warn("Player stuck! Forcing respawn.");
                duelState.localPlayer.respawn();
            }
        }

        
        // --- EVENT LISTENERS ---
        function setupEventListeners() {
            window.addEventListener('mousemove', () => { if(!duelState.active && !zombieModeState.active) showUI() });
            document.body.addEventListener('mouseleave', () => { if(!duelState.active && !zombieModeState.active) hideUI() });
            window.addEventListener('touchstart', () => { if(!duelState.active && !zombieModeState.active) showUI() });


            playPauseBtn.addEventListener('click', () => {
                startAudioContext();
                if (state.isRunning) {
                    pauseTimer();
                } else {
                    startTimer();
                }
            });
            resetBtn.addEventListener('click', resetTimer);
            
            const toggleFullscreen = () => {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch(err => {
                        console.error(`Error al intentar activar el modo de pantalla completa: ${err.message} (${err.name})`);
                    });
                } else {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    }
                }
            };

            fullscreenBtn.addEventListener('click', toggleFullscreen);
            fullscreenMenuBtn.addEventListener('click', () => {
                toggleFullscreen();
                mainMenuDropdown.classList.add('hidden');
            });


            // Modals
            settingsBtn.addEventListener('click', () => settingsModal.classList.add('active'));
            tasksBtn.addEventListener('click', () => tasksModal.classList.add('active'));
            aiTutorBtn.addEventListener('click', () => aiTutorModal.classList.add('active'));
            multiplayerBtn.addEventListener('click', () => {
                if(currentGameState.inMultiplayer) {
                    // Using custom modal instead of confirm
                    const leaveModal = document.createElement('div');
                    leaveModal.innerHTML = `<div class="modal active"><div class="modal-content" style="max-width: 400px; text-align: center;"><p style="margin-bottom: 1rem;">¿Quieres salir de la partida multijugador actual?</p><button class="modal-button" id="confirm-leave">Sí, salir</button><button class="modal-button secondary" id="cancel-leave">Cancelar</button></div></div>`;
                    document.body.appendChild(leaveModal);
                    document.getElementById('confirm-leave').onclick = () => {
                        leaveGame();
                        document.body.removeChild(leaveModal);
                    };
                    document.getElementById('cancel-leave').onclick = () => document.body.removeChild(leaveModal);

                } else {
                    multiplayerModal.classList.add('active');
                    showMultiplayerView('multiplayer-initial');
                }
            });
            
            document.querySelectorAll('.modal-close-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const targetModalId = e.currentTarget.dataset.target;
                    document.getElementById(targetModalId).classList.remove('active');
                });
            });
            
            [settingsModal, tasksModal, aiTutorModal, multiplayerModal, classSelectionModal].forEach(modal => {
                if (modal) {
                    modal.addEventListener('click', (e) => {
                        if(e.target === modal) modal.classList.remove('active');
                    });
                }
            });
            
            
            workDurationInput.addEventListener('change', updateDurations);
            shortBreakDurationInput.addEventListener('change', updateDurations);
            longBreakDurationInput.addEventListener('change', updateDurations);

            biomeBtn.addEventListener('click', ()=>changeBiome());
            
            speedToggleBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                speedOptions.classList.toggle('hidden');
                if (!speedOptions.classList.contains('hidden')) {
                    if (speedTimeoutId) clearTimeout(speedTimeoutId);
                    speedTimeoutId = setTimeout(() => speedOptions.classList.add('hidden'), 10000);
                }
            });

            speedOptions.addEventListener('click', (e) => {
                if (e.target.matches('.speed-button')) {
                    const newSpeed = parseFloat(e.target.dataset.speed);
                    changeSpeed(newSpeed);
                    speedOptions.classList.add('hidden');
                    if (speedTimeoutId) clearTimeout(speedTimeoutId);
                }
            });
            
            soundMenuBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                soundPanel.classList.toggle('active');
            });

            document.getElementById('sound-buttons').addEventListener('click', (e) => {
                startAudioContext();
                const soundButton = e.target.closest('.sound-button');
                if (soundButton) {
                    currentSound = soundButton.dataset.sound;
                    document.querySelectorAll('.sound-button').forEach(btn => btn.classList.remove('active'));
                    soundButton.classList.add('active');
                    if(state.isRunning) {
                        playCurrentSound();
                    }
                }
            });

            volumeSlider.addEventListener('input', () => updateVolume());

            document.addEventListener('click', (e) => {
                if ((duelState.active || zombieModeState.active) && !pointerLockControls.isLocked) {
                   // Pointer lock is now handled by enableShooterControls
                }
                if (soundPanel && !soundPanel.contains(e.target) && !soundMenuBtn.contains(e.target)) {
                    soundPanel.classList.remove('active');
                }
                if (languageDropdown && !languageDropdown.contains(e.target) && !languageBtn.contains(e.target)) {
                    languageDropdown.classList.add('hidden');
                }
                if (mainMenuDropdown && !mainMenuDropdown.contains(e.target) && !mainMenuBtn.contains(e.target)) {
                    mainMenuDropdown.classList.add('hidden');
                }
                if (speedOptions && !speedControls.contains(e.target)) {
                    speedOptions.classList.add('hidden');
                    if(speedTimeoutId) clearTimeout(speedTimeoutId);
                }
            });
            
            aiTutorGenerateBtn.addEventListener('click', getTutorExplanation);
            
            const toggleLanguageDropdown = (e) => {
                e.stopPropagation();
                languageDropdown.classList.toggle('hidden');
                mainMenuDropdown.classList.add('hidden');
            };
            languageBtn.addEventListener('click', toggleLanguageDropdown);
            languageMenuBtn.addEventListener('click', toggleLanguageDropdown);

            document.querySelectorAll('#language-dropdown .menu-option').forEach(option => {
                option.addEventListener('click', () => {
                    applyLanguage(option.dataset.lang);
                    languageDropdown.classList.add('hidden');
                });
            });

            mainMenuBtn.addEventListener('click', (e) => {
                 e.stopPropagation();
                mainMenuDropdown.classList.toggle('hidden');
            });

            // Tasks Listeners
            newTaskInput.addEventListener('keypress', (e) => {
                if(e.key === 'Enter') {
                    addTask();
                }
            });
            
            taskList.addEventListener('click', (e) => {
                 const deleteBtn = e.target.closest('.delete-task');
                if (deleteBtn) {
                    const id = parseInt(deleteBtn.closest('li').dataset.id);
                    deleteTask(id);
                }

                 const checkbox = e.target.closest('input[type="checkbox"]');
                if (checkbox) {
                     const id = parseInt(checkbox.closest('li').dataset.id);
                     toggleTask(id);
                }
            });
            
            // Multiplayer Listeners
            hostBtn.addEventListener('click', () => showMultiplayerView('multiplayer-host-options'));
            joinBtn.addEventListener('click', () => showMultiplayerView('multiplayer-join'));
            document.querySelectorAll('#back-to-initial-btn, #back-to-initial-btn-2').forEach(btn => {
                btn.addEventListener('click', () => showMultiplayerView('multiplayer-initial'));
            });
            coopModeBtn.addEventListener('click', () => hostGame('cooperative'));
            versusModeBtn.addEventListener('click', () => hostGame('versus'));
            joinGameSubmitBtn.addEventListener('click', () => {
                const code = gameCodeInput.value.trim().toUpperCase();
                if(code) joinGame(code);
            });
            copyCodeBtn.addEventListener('click', () => {
                navigator.clipboard.writeText(gameCodeDisplay.textContent).then(() => {
                    const feedback = document.getElementById('game-code-copy-feedback');
                    feedback.style.opacity = '1';
                    setTimeout(() => feedback.style.opacity = '0', 1500);
                });
            });

            exportGameBtn.addEventListener('click', exportGame);
            importGameInput.addEventListener('change', importGame);

            // Duel and Zombie Mode Listeners
            duelModeBtn.addEventListener('click', handleDuelButtonClick);
            classSelectionModal.addEventListener('click', handleClassSelection);
            document.getElementById('close-duel-results-btn').addEventListener('click', closeDuelResults);
            document.getElementById('zombie-respawn-btn').addEventListener('click', () => {
                document.getElementById('zombie-death-modal').classList.remove('active');
                const lastClass = duelState.localPlayer ? duelState.localPlayer.playerClass : 'soldier';
                endZombieMode(false, false); // No mostrar resultados, no reiniciar timer
                startZombieMode(lastClass);
            });
            document.getElementById('zombie-exit-btn').addEventListener('click', () => {
                document.getElementById('zombie-death-modal').classList.remove('active');
                endZombieMode(false, true);
            });
            document.getElementById('close-zombie-results-btn').addEventListener('click', () => {
                document.getElementById('zombie-results-modal').classList.remove('active');
            });


            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        
        // --- ANIMATION LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            
            if (!document.getElementById('credit-line')) {
                addCreditLine();
            }

            const delta = clock.getDelta();

            if (duelState.localPlayer) {
                duelState.localPlayer.update(delta);
            }
             if (duelState.remotePlayer && duelState.remotePlayer.userData.targetPosition) {
                duelState.remotePlayer.position.lerp(duelState.remotePlayer.userData.targetPosition, delta * 10);
                const q = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), duelState.remotePlayer.userData.targetRotationY);
                duelState.remotePlayer.quaternion.slerp(q, delta * 10);
            }
            if ((duelState.active || zombieModeState.active) && duelState.localPlayer) {
                checkIfStuck(); 
            } else {
                orbitControls.update();
            }
            
            // Animate growing trees
            grove.forEach(tree => {
                if (tree.userData.isGrowing) {
                    const scale = tree.scale.x;
                    const targetScale = tree.userData.targetScale;
                    if (scale < targetScale) {
                        const newScale = scale + delta * 0.8; // Growth speed
                        tree.scale.set(newScale, newScale, newScale);
                    } else {
                        tree.scale.set(targetScale, targetScale, targetScale); // Clamp to target
                        tree.userData.isGrowing = false;
                    }
                }
            });

            // Update projectiles
            for (let i = duelState.projectiles.length - 1; i >= 0; i--) {
                const p = duelState.projectiles[i];
                p.position.addScaledVector(p.userData.velocity, delta);
                let projectileRemoved = false;

                // --- Collision Logic ---
                if (p.userData.owner === userId) {
                    if (zombieModeState.active) {
                        // Hitting zombies
                        for (let j = zombieModeState.zombies.length - 1; j >= 0; j--) {
                            const z = zombieModeState.zombies[j];
                            if (p.position.distanceTo(z.mesh.position) < 1.2) {
                                const damage = duelState.localPlayer.classStats.weapon.damage;
                                z.takeDamage(damage);
                                scene.remove(p);
                                duelState.projectiles.splice(i, 1);
                                projectileRemoved = true;
                                break; 
                            }
                        }
                    } else if (duelState.remotePlayer) {
                        // Hitting opponent in duel mode
                        const remotePlayerBox = new THREE.Box3().setFromObject(duelState.remotePlayer);
                        if (remotePlayerBox.containsPoint(p.position)) {
                             if (currentGameState.inMultiplayer) {
                                if(isAudioReady && soundSources.hit_marker) {
                                    soundSources.hit_marker.triggerAttackRelease("C7", "32n");
                                }
                                const opponentId = currentGameState.playerIds.find(id => id !== userId);
                                const myClass = duelState.players[userId].class;
                                const damage = CLASS_STATS[myClass].weapon.damage;
                                const gameRef = doc(db, `artifacts/${appId}/public/data/games`, currentGameState.gameId);
                                const plainProjectileData = p.userData.originalData;

                                updateDoc(gameRef, {
                                    [`duel.players.${opponentId}.health`]: increment(-damage),
                                    projectiles: arrayRemove(plainProjectileData)
                                });
                            }
                            scene.remove(p);
                            duelState.projectiles.splice(i, 1);
                            projectileRemoved = true;
                        }
                    }
                }
                if (projectileRemoved) continue;

                // Hitting Trees
                let hitTree = false;
                for (const tree of grove) {
                    const trunk = tree.children[0];
                    if (trunk) {
                        const trunkBox = new THREE.Box3().setFromObject(trunk);
                        if (trunkBox.containsPoint(p.position)) {
                            hitTree = true;
                            break;
                        }
                    }
                }
                if (hitTree) {
                    scene.remove(p);
                    duelState.projectiles.splice(i, 1);
                    continue;
                }

                // Despawn projectile after time/range
                if (Date.now() - p.userData.spawnTime > p.userData.range * 100) {
                    scene.remove(p);
                    duelState.projectiles.splice(i, 1);
                }
            }
            
            // ===== ZOMBIE MODE LOGIC =====
            if (zombieModeState.active) {
                zombieModeState.waveTimer -= delta;
                const playerPosition = duelState.localPlayer ? pointerLockControls.getObject().position : new THREE.Vector3();
                for (let i = zombieModeState.zombies.length - 1; i >= 0; i--) {
                    zombieModeState.zombies[i].update(delta, playerPosition);
                }
                if (zombieModeState.zombies.length === 0 || zombieModeState.waveTimer <= 0) {
                    startNextWave();
                }
            }


            renderer.render(scene, camera);
        }

        // --- INITIALIZATION ---
        async function main() {
            const deployedFirebaseConfig = {
              apiKey: "AIzaSyDigVtE9WexPsg0gOvjcsuYVO_FX-r__7o",
              authDomain: "interfaces-4bc20.firebaseapp.com",
              projectId: "interfaces-4bc20",
              storageBucket: "interfaces-4bc20.appspot.com",
              messagingSenderId: "1007775332703",
              appId: "1:1007775332703:web:d28af78317f63cfaa75eea",
              measurementId: "G-2XGZ3JEY94"
            };

            const firebaseConfig = typeof __firebase_config !== 'undefined' 
                ? JSON.parse(__firebase_config)
                : deployedFirebaseConfig;

            const app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);

            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
                
                userId = auth.currentUser?.uid;
                if (!userId) {
                    throw new Error("Authentication failed, user ID is null.");
                }
                
                console.log("Authenticated with user ID:", userId);
                
                multiplayerBtn.disabled = false;
                
                init3D();
                initAudio();
                loadTasks();
                setupEventListeners();
                animate();

                showUI(); // Start inactivity timer

                const savedLang = localStorage.getItem('language') || 'es';
                applyLanguage(savedLang);
                switchMode('focus');
                changeSpeed(1); // Set initial speed to 1x and update UI

            } catch (error) {
                console.error("Initialization Error:", error);
                alert("No se pudo iniciar la aplicación. Por favor, recarga la página.");
            }
        }
        
        main();

        // ===== PLAYER CONTROLLER COMPLETAMENTE REESCRITO =====
        class PlayerController {
            constructor(isLocal, playerClass) {
                this.isLocal = isLocal;
                this.playerClass = playerClass;
                this.classStats = CLASS_STATS[playerClass];
                this.health = this.classStats.maxHealth;
                this.velocity = new THREE.Vector3();
                this.direction = new THREE.Vector3();
                this.onGround = false;
                this.isRespawning = false;
                this.lastShotTime = 0;
                this.lastSyncTime = 0;
                this.bobTime = 0;
                this.recoil = new THREE.Vector3();
                this.recoilTarget = new THREE.Vector3();
                // Nuevos: Detección de estado inválido
                this.fallTimer = 0;
                this.stuckTimer = 0;
                this.lastValidPosition = new THREE.Vector3(0, 20, 0);
                this.timeSinceLastHit = 0; // Para regeneración de vida
                this.lastHitTime = 0;
                this.keys = {
                    KeyW: false,
                    KeyA: false,
                    KeyS: false,
                    KeyD: false,
                    Space: false,
                    ShiftLeft: false
                };
                this.mouse = {
                    down: false
                };
                if (this.isLocal) {
                    this.camera = camera;
                    this.weapon = this.createWeaponMesh(playerClass);
                    this.camera.add(this.weapon);
                    this.mesh = new THREE.Group();
                    document.addEventListener('keydown', (e) => {
                        if (this.keys.hasOwnProperty(e.code)) {
                            this.keys[e.code] = true;
                        }
                    });
                    document.addEventListener('keyup', (e) => {
                        if (this.keys.hasOwnProperty(e.code)) {
                            this.keys[e.code] = false;
                        }
                    });
                    document.addEventListener('mousedown', () => {
                        if (pointerLockControls.isLocked) {
                            this.mouse.down = true;
                        }
                    });
                    document.addEventListener('mouseup', () => {
                        this.mouse.down = false;
                    });
                } else {
                    const bodyGeo = new THREE.CapsuleGeometry(0.5, 1, 4, 8);
                    const bodyMat = new THREE.MeshStandardMaterial({
                        color: 0xff0000
                    });
                    this.mesh = new THREE.Mesh(bodyGeo, bodyMat);
                    scene.add(this.mesh);
                    this.mesh.position.set(Math.random() * 40 - 20, 20, Math.random() * 40 - 20);
                }
            }
            takeDamage(amount) {
                if (this.isRespawning) return;
                this.health -= amount;
                if (this.health < 0) this.health = 0;
                this.timeSinceLastHit = 0; // Reset regen timer

                const now = performance.now();
                if (now - this.lastHitTime > 200) { // Cooldown for hit sound
                    this.lastHitTime = now;
                    if (isAudioReady && soundSources.player_hit) {
                        soundSources.player_hit.triggerAttackRelease("G1", "8n");
                    }
                }

                updateDuelHud();
            }
            playShotSound() {
                if (!isAudioReady) return;
                switch (this.playerClass) {
                    case 'scout':
                        soundSources.shot_pistol.triggerAttack();
                        break;
                    case 'soldier':
                        soundSources.shot_rifle.triggerAttack();
                        break;
                    case 'tank':
                        soundSources.shot_shotgun.triggerAttack();
                        break;
                }
            }
            createWeaponMesh(playerClass) {
                const weaponGroup = new THREE.Group();
                const darkGray = new THREE.MeshStandardMaterial({
                    color: 0x333333,
                    roughness: 0.4,
                    metalness: 0.5
                });
                const lightGray = new THREE.MeshStandardMaterial({
                    color: 0x888888,
                    roughness: 0.4,
                    metalness: 0.7
                });
                switch (playerClass) {
                    case 'scout':
                        const pistolBody = new THREE.Mesh(
                            new THREE.BoxGeometry(0.08, 0.1, 0.2),
                            darkGray
                        );
                        const pistolGrip = new THREE.Mesh(
                            new THREE.BoxGeometry(0.06, 0.2, 0.06),
                            darkGray
                        );
                        pistolGrip.position.set(0, -0.1, -0.05);
                        pistolGrip.rotation.x = 0.2;
                        const pistolBarrel = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.02, 0.02, 0.15, 8),
                            lightGray
                        );
                        pistolBarrel.position.set(0, 0.03, 0.15);
                        pistolBarrel.rotation.x = Math.PI / 2;
                        weaponGroup.add(pistolBody, pistolGrip, pistolBarrel);
                        break;
                    case 'soldier':
                        const rifleBody = new THREE.Mesh(
                            new THREE.BoxGeometry(0.1, 0.12, 0.5),
                            darkGray
                        );
                        const rifleBarrel = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.025, 0.025, 0.4, 8),
                            lightGray
                        );
                        rifleBarrel.position.set(0, -0.02, 0.45);
                        rifleBarrel.rotation.x = Math.PI / 2;
                        const rifleScope = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.03, 0.03, 0.15, 12),
                            darkGray
                        );
                        rifleScope.position.set(0, 0.1, 0);
                        rifleScope.rotation.z = Math.PI / 2;
                        weaponGroup.add(rifleBody, rifleBarrel, rifleScope);
                        break;
                    case 'tank':
                        const shotgunBody = new THREE.Mesh(
                            new THREE.BoxGeometry(0.12, 0.14, 0.6),
                            darkGray
                        );
                        const shotgunBarrel = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.05, 0.05, 0.5, 8),
                            lightGray
                        );
                        shotgunBarrel.position.set(0, -0.02, 0.4);
                        shotgunBarrel.rotation.x = Math.PI / 2;
                        weaponGroup.add(shotgunBody, shotgunBarrel);
                        break;
                }
                weaponGroup.position.set(0.25, -0.4, -0.6);
                return weaponGroup;
            }
            dispose() {
                if (this.isLocal && this.weapon) {
                    this.camera.remove(this.weapon);
                }
                scene.remove(this.mesh);
            }
            // ===== NUEVO SISTEMA DE SPAWN ROBUSTO =====
            async respawn() {
                console.log("🔄 Iniciando respawn...");
                this.health = this.classStats.maxHealth;
                this.isRespawning = true;
                this.onGround = false;
                this.velocity.set(0, 0, 0);
                const MAX_ATTEMPTS = 50;
                const MIN_TREE_DISTANCE = 3.5; // Distancia segura de árboles
                const SPAWN_RADIUS = 70;
                const MIN_HEIGHT = 2; // Altura mínima válida del terreno
                const MAX_HEIGHT = 25; // Altura máxima válida
                const CAMERA_HEIGHT = 1.8;
                let bestSpawn = null;
                let bestScore = -Infinity;
                // Buscar la MEJOR posición, no solo una válida
                for (let attempt = 0; attempt < MAX_ATTEMPTS; attempt++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * SPAWN_RADIUS;
                    const testX = Math.cos(angle) * radius;
                    const testZ = Math.sin(angle) * radius;
                    // Validar altura del terreno
                    const testY = getHeightAt(testX, -testZ);
                    if (!isFinite(testY) || testY < MIN_HEIGHT || testY > MAX_HEIGHT) {
                        continue; // Terreno inválido
                    }
                    // Calcular distancia mínima a cualquier árbol
                    let minTreeDist = Infinity;
                    let tooClose = false;
                    for (const tree of grove) {
                        const dx = testX - tree.position.x;
                        const dz = testZ - tree.position.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        if (dist < MIN_TREE_DISTANCE) {
                            tooClose = true;
                            break;
                        }
                        minTreeDist = Math.min(minTreeDist, dist);
                    }
                    if (tooClose) continue;
                    // Puntuación: prefiere zonas planas y lejos de árboles
                    const flatness = 10 - Math.abs(testY - 10); // Prefiere altura media
                    const treeScore = Math.min(minTreeDist, 10); // Bonus por lejanía
                    const score = flatness + treeScore;
                    if (score > bestScore) {
                        bestScore = score;
                        bestSpawn = {
                            x: testX,
                            y: testY,
                            z: testZ
                        };
                    }
                }
                // Fallback absoluto si no se encuentra posición
                if (!bestSpawn) {
                    console.warn("⚠️ No se encontró spawn seguro, usando posición central elevada");
                    bestSpawn = {
                        x: 0,
                        y: 15,
                        z: 0
                    };
                }
                const finalPos = new THREE.Vector3(
                    bestSpawn.x,
                    bestSpawn.y + CAMERA_HEIGHT,
                    bestSpawn.z
                );
                console.log(`✅ Spawn encontrado en (${finalPos.x.toFixed(2)}, ${finalPos.y.toFixed(2)}, ${finalPos.z.toFixed(2)})`);
                // Aplicar posición
                if (this.isLocal) {
                    const cameraObject = pointerLockControls.getObject();
                    cameraObject.position.copy(finalPos);
                    // Resetear rotación vertical para evitar pantalla negra
                    camera.rotation.x = 0;
                    camera.rotation.z = 0;
                } else {
                    this.mesh.position.copy(finalPos);
                }
                // Guardar como última posición válida
                this.lastValidPosition.copy(finalPos);
                this.fallTimer = 0;
                this.stuckTimer = 0;
                this.isRespawning = false;
                // Sincronizar con Firebase si es necesario
                if (this.isLocal && currentGameState.inMultiplayer) {
                    const gameRef = doc(db, `artifacts/${appId}/public/data/games`, currentGameState.gameId);
                    await updateDoc(gameRef, {
                        [`duel.players.${userId}.position`]: {
                            x: finalPos.x,
                            y: finalPos.y,
                            z: finalPos.z
                        },
                        [`duel.players.${userId}.health`]: this.health
                    });
                }
            }
            // ===== SISTEMA DE MOVIMIENTO MEJORADO CON VALIDACIONES =====
            update(delta) {
                if (!this.isLocal) return;
                const cameraObject = pointerLockControls.getObject();
                
                // 1. Detección de caída infinita y vida cero
                if ((cameraObject.position.y < -5 || this.health <= 0) && !this.isRespawning) {
                    if (zombieModeState.active) {
                        document.getElementById('death-modal-round').textContent = zombieModeState.round;
                        document.getElementById('death-modal-kills').textContent = zombieModeState.kills;
                        document.getElementById('zombie-death-modal').classList.add('active');
                        disableShooterControls();
                        this.isRespawning = true; 
                        pauseTimer(); // CAMBIO: Pausar el temporizador al morir
                    } else if (currentGameState.inMultiplayer) {
                        const opponentId = currentGameState.playerIds.find(id => id !== userId);
                        const gameRef = doc(db, `artifacts/${appId}/public/data/games`, currentGameState.gameId);
                        updateDoc(gameRef, { [`duel.players.${opponentId}.score`]: increment(1) });
                        this.respawn();
                    }
                    return;
                }

                // 2. Detección de caída prolongada (más de 3 segundos cayendo)
                if (this.velocity.y < -5 && !this.onGround) {
                    this.fallTimer += delta;
                    if (this.fallTimer > 3.0) {
                        console.warn("❌ Caída prolongada detectada, respawneando...");
                        this.respawn();
                        return;
                    }
                } else {
                    this.fallTimer = 0;
                }
                // 3. Detección de atascamiento (sin movimiento durante 2 segundos)
                if (pointerLockControls.isLocked) {
                    const distMoved = cameraObject.position.distanceTo(this.lastValidPosition);
                    if (distMoved < 0.1 && (this.keys.KeyW || this.keys.KeyS || this.keys.KeyA || this.keys.KeyD)) {
                        this.stuckTimer += delta;
                        if (this.stuckTimer > 2.0) {
                            console.warn("❌ Jugador atascado, respawneando...");
                            this.respawn();
                            return;
                        }
                    } else if (distMoved > 0.5) {
                        this.stuckTimer = 0;
                        this.lastValidPosition.copy(cameraObject.position);
                    }
                }
                 // ===== REGENERACIÓN DE VIDA =====
                this.timeSinceLastHit += delta;
                if (this.timeSinceLastHit > 5.0 && this.health < this.classStats.maxHealth) {
                    const regenRate = 20; // Health per second
                    this.health += regenRate * delta;
                    if (this.health > this.classStats.maxHealth) {
                        this.health = this.classStats.maxHealth;
                    }
                    updateDuelHud(); // Update the UI
                }
                // ===== MOVIMIENTO Y COLISIONES =====
                const speed = this.classStats.speed;
                const isMoving = this.keys.KeyW || this.keys.KeyS || this.keys.KeyA || this.keys.KeyD;
                // Gravedad
                const gravity = this.isRespawning ? 8.0 : 30.0;
                this.velocity.y -= gravity * delta;
                // Dirección de movimiento
                this.direction.z = Number(this.keys.KeyW) - Number(this.keys.KeyS);
                this.direction.x = Number(this.keys.KeyA) - Number(this.keys.KeyD);
                this.direction.normalize();
                const effectiveSpeed = this.keys.ShiftLeft ? speed * 1.5 : speed;
                // Calcular vectores de movimiento
                const forwardVector = new THREE.Vector3();
                cameraObject.getWorldDirection(forwardVector);
                forwardVector.y = 0;
                forwardVector.normalize();
                const rightVector = new THREE.Vector3().crossVectors(cameraObject.up, forwardVector);
                const moveX = (this.direction.x * rightVector.x + this.direction.z * forwardVector.x) * effectiveSpeed * delta;
                const moveZ = (this.direction.x * rightVector.z + this.direction.z * forwardVector.z) * effectiveSpeed * delta;
                // Calcular próxima posición
                const nextPos = cameraObject.position.clone();
                nextPos.x += moveX;
                nextPos.z += moveZ;
                // ===== COLISIÓN MEJORADA CON ÁRBOLES =====
                let collision = false;
                const PLAYER_RADIUS = 0.6; // Radio del jugador
                const TREE_RADIUS = 0.8; // Radio del tronco del árbol
                for (const tree of grove) {
                    const dx = nextPos.x - tree.position.x;
                    const dz = nextPos.z - tree.position.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    if (distance < PLAYER_RADIUS + TREE_RADIUS) {
                        collision = true;
                        // Empujar al jugador fuera del árbol (slide)
                        const pushAngle = Math.atan2(dz, dx);
                        const pushDist = (PLAYER_RADIUS + TREE_RADIUS) - distance + 0.1;
                        nextPos.x += Math.cos(pushAngle) * pushDist;
                        nextPos.z += Math.sin(pushAngle) * pushDist;
                        break;
                    }
                }
                // Aplicar movimiento horizontal solo si no hay colisión frontal
                if (!collision) {
                    cameraObject.position.x = nextPos.x;
                    cameraObject.position.z = nextPos.z;
                }
                
                // ===== MOVIMIENTO VERTICAL Y TERRENO REFACTORIZADO =====
                cameraObject.position.y += this.velocity.y * delta;
                let onSolidSurface = false;
                const playerFeetY = cameraObject.position.y - 1.8;

                // 1. Comprobar colisión con copas de los árboles primero
                if (this.velocity.y <= 0) { // Solo comprobar al caer
                    for (const tree of grove) {
                        const dx = cameraObject.position.x - tree.position.x;
                        const dz = cameraObject.position.z - tree.position.z;
                        const horizontalDistSq = dx * dx + dz * dz;
                        const canopyCheckRadiusSq = 3 * 3; // Radio de comprobación generoso

                        if (horizontalDistSq < canopyCheckRadiusSq) {
                            // Saltar el tronco (hijo 0) y comprobar las otras partes
                            for (let i = 1; i < tree.children.length; i++) {
                                const canopyPart = tree.children[i];
                                const canopyBox = new THREE.Box3().setFromObject(canopyPart);
                                if (cameraObject.position.x > canopyBox.min.x && cameraObject.position.x < canopyBox.max.x &&
                                    cameraObject.position.z > canopyBox.min.z && cameraObject.position.z < canopyBox.max.z) {
                                    
                                    const canopyTopY = canopyBox.max.y;
                                    // Comprobar si el jugador estaba arriba y ahora está en o debajo de la copa
                                    if (playerFeetY <= canopyTopY && (playerFeetY - this.velocity.y * delta) > canopyTopY) {
                                        this.velocity.y = 0;
                                        cameraObject.position.y = canopyTopY + 1.8;
                                        onSolidSurface = true;
                                        break;
                                    }
                                }
                            }
                        }
                        if (onSolidSurface) break;
                    }
                }

                // 2. Si no está en una copa, comprobar colisión con el suelo
                if (!onSolidSurface) {
                    const groundY = getHeightAt(cameraObject.position.x, -cameraObject.position.z) + 1.8;
                    if (!isFinite(groundY)) {
                        console.warn("⚠️ Altura de terreno inválida, respawneando...");
                        this.respawn();
                        return;
                    }
                    if (cameraObject.position.y <= groundY) {
                        this.velocity.y = 0;
                        cameraObject.position.y = groundY;
                        onSolidSurface = true;
                    }
                }

                // Establecer estado onGround
                this.onGround = onSolidSurface;
                if (this.onGround && this.isRespawning) {
                    this.isRespawning = false;
                }

                // Salto
                if (this.keys.Space && this.onGround) {
                    this.velocity.y = this.classStats.jumpHeight;
                }
                
                // Sincronizar mesh del jugador
                this.mesh.position.set(
                    cameraObject.position.x,
                    cameraObject.position.y - 0.8,
                    cameraObject.position.z
                );
                // ===== DISPARO =====
                if (this.mouse.down && pointerLockControls.isLocked) {
                    const now = Date.now();
                    if (now - this.lastShotTime >= this.classStats.weapon.fireRate) {
                        this.lastShotTime = now;
                        this.playShotSound();
                        this.recoilTarget.z = 0.1;
                        const direction = new THREE.Vector3();
                        this.camera.getWorldDirection(direction);
                        const spawnPos = this.camera.position.clone().add(direction.clone().multiplyScalar(0.5)); // Spawn slightly in front
                        
                        const projectileData = {
                            id: THREE.MathUtils.generateUUID(),
                            owner: userId,
                            position: { x: spawnPos.x, y: spawnPos.y, z: spawnPos.z },
                            velocity: { x: direction.x * this.classStats.weapon.projectileSpeed, y: direction.y * this.classStats.weapon.projectileSpeed, z: direction.z * this.classStats.weapon.projectileSpeed },
                            range: this.classStats.weapon.range,
                        };
                        spawnProjectile(projectileData, true);
                    }
                }
                // ===== ANIMACIÓN DE ARMA =====
                this.bobTime += delta * (speed * (isMoving && this.onGround ? 0.2 : 0));
                this.weapon.position.y = -0.4 + Math.sin(this.bobTime) * 0.02;
                this.weapon.position.x = 0.25 + Math.cos(this.bobTime * 0.5) * 0.01;
                this.recoil.lerp(this.recoilTarget, delta * 20);
                this.recoilTarget.lerp(new THREE.Vector3(), delta * 10);
                this.weapon.position.z = -0.6 - this.recoil.z;
                // ===== SINCRONIZACIÓN FIREBASE =====
                if (Date.now() - this.lastSyncTime >= 100) {
                    this.lastSyncTime = Date.now();
                    if (currentGameState.inMultiplayer) {
                        const gameRef = doc(db, `artifacts/${appId}/public/data/games`, currentGameState.gameId);
                        updateDoc(gameRef, {
                            [`duel.players.${userId}.position`]: {
                                x: this.mesh.position.x,
                                y: this.mesh.position.y,
                                z: this.mesh.position.z
                            },
                            [`duel.players.${userId}.rotationY`]: this.camera.rotation.y
                        });
                    }
                }
            }
        }
        
        // --- ZOMBIE CONTROLLER CLASS ---
        class ZombieController {
            constructor() {
                const faceTexture = this.createZombieFaceTexture();

                const bodyGeo = new THREE.CapsuleGeometry(0.6, 1.2, 4, 8);
                const bodyMat = new THREE.MeshStandardMaterial({
                    roughness: 1,
                    map: faceTexture
                });
                this.mesh = new THREE.Mesh(bodyGeo, bodyMat);
                this.mesh.castShadow = true;
                
                const baseHealth = 60; // Start with 60 HP
                this.health = baseHealth * Math.pow(1.2, zombieModeState.round - 1); // 20% increase per round
                
                this.speed = 2.4 + (zombieModeState.round * 0.35); // Speed increases more per round
                this.damage = 50; 
                this.attackCooldown = 0;
                this.velocity = new THREE.Vector3();
                this.onGround = false;
                this.lastStepTime = 0;
                this.lastGrowlTime = Date.now();
                this.nextGrowlDelay = 5000 + Math.random() * 8000;

                this.spawn();
                scene.add(this.mesh);
            }

            createZombieFaceTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 128;
                canvas.height = 128;
                const context = canvas.getContext('2d');

                // Background: Green/Purple Radial Gradient for a diffused look
                const gradient = context.createRadialGradient(64, 64, 10, 64, 64, 80);
                gradient.addColorStop(0, '#43a047'); // Green center
                gradient.addColorStop(1, '#5e35b1'); // Purple outer
                context.fillStyle = gradient;
                context.fillRect(0, 0, 128, 128);

                // Add some noise/texture to the skin
                for (let i = 0; i < 1000; i++) {
                    context.fillStyle = `rgba(0, 0, 0, ${Math.random() * 0.2})`;
                    context.fillRect(Math.random() * 128, Math.random() * 128, 2, 2);
                }
                
                // Sunken eye sockets
                context.fillStyle = 'rgba(0,0,0,0.5)';
                context.beginPath();
                context.arc(45, 50, 12, 0, Math.PI * 2);
                context.fill();
                context.beginPath();
                context.arc(83, 50, 12, 0, Math.PI * 2);
                context.fill();


                // Eyes (glowing red)
                context.fillStyle = '#ff1744'; // Bright red
                context.beginPath();
                context.arc(45, 50, 8, 0, Math.PI * 2); // Left eye
                context.fill();
                context.beginPath();
                context.arc(83, 50, 8, 0, Math.PI * 2); // Right eye
                context.fill();
                
                // Add a smaller, brighter pupil
                context.fillStyle = '#ff8a80'; // Lighter red
                context.beginPath();
                context.arc(45, 50, 3, 0, Math.PI * 2);
                context.fill();
                context.beginPath();
                context.arc(83, 50, 3, 0, Math.PI * 2);
                context.fill();

                // Mouth (gaping)
                context.fillStyle = 'black';
                context.beginPath();
                context.ellipse(64, 90, 25, 10, 0, 0, Math.PI * 2);
                context.fill();
                
                // Jagged Teeth
                context.fillStyle = '#bbbbbb';
                for(let i=0; i < 5; i++) {
                    const x = 45 + i * 8;
                    context.beginPath();
                    context.moveTo(x, 82);
                    context.lineTo(x + 4, 82);
                    context.lineTo(x + 2, 86);
                    context.closePath();
                    context.fill();
                }

                return new THREE.CanvasTexture(canvas);
            }

            spawn() {
                const SPAWN_RADIUS = 80;
                const angle = Math.random() * Math.PI * 2;
                const radius = SPAWN_RADIUS * (0.8 + Math.random() * 0.2); // Spawn further away
                const spawnX = Math.cos(angle) * radius;
                const spawnZ = Math.sin(angle) * radius;
                const spawnY = getHeightAt(spawnX, -spawnZ) + 10;
                this.mesh.position.set(spawnX, spawnY, spawnZ);
            }

            update(delta, playerPosition) {
                if (this.attackCooldown > 0) {
                    this.attackCooldown -= delta;
                }

                // --- Navigation ---
                const direction = playerPosition.clone().sub(this.mesh.position).normalize();
                direction.y = 0; // Zombies don't fly

                this.velocity.x = direction.x * this.speed;
                this.velocity.z = direction.z * this.speed;

                // --- Gravity and Ground Collision ---
                this.velocity.y -= 30 * delta; // Gravity
                this.mesh.position.x += this.velocity.x * delta;
                this.mesh.position.z += this.velocity.z * delta;
                this.mesh.position.y += this.velocity.y * delta;
                
                const groundY = getHeightAt(this.mesh.position.x, -this.mesh.position.z) + 1.1; // Capsule half-height

                if (this.mesh.position.y < groundY) {
                    this.mesh.position.y = groundY;
                    this.velocity.y = 0;
                    this.onGround = true;
                } else {
                    this.onGround = false;
                }
                
                // Make zombie look at player
                this.mesh.lookAt(playerPosition.x, this.mesh.position.y, playerPosition.z);

                // --- Sound Effects ---
                const distanceToPlayer = this.mesh.position.distanceTo(playerPosition);
                if (this.onGround && this.velocity.lengthSq() > 0.1) {
                    if (Date.now() - this.lastStepTime > 500) { // Step every 500ms
                        this.lastStepTime = Date.now();
                        const volume = -20 - Math.min(distanceToPlayer * 1.5, 20);
                        
                        // Use the synth pool for steps
                        const stepSynth = soundSources.zombie_steps[soundSources.zombie_step_index];
                        if (stepSynth.state === 'stopped') {
                           stepSynth.volume.value = volume;
                           stepSynth.triggerAttackRelease("C1", "16n", Tone.now());
                           soundSources.zombie_step_index = (soundSources.zombie_step_index + 1) % soundSources.zombie_steps.length;
                        }
                    }
                }
                if (Date.now() - this.lastGrowlTime > this.nextGrowlDelay) {
                    this.lastGrowlTime = Date.now();
                    this.nextGrowlDelay = 8000 + Math.random() * 8000;
                    const volume = -15 - Math.min(distanceToPlayer, 20);
                    
                    // Use the synth pool for growls
                    const growlSynth = soundSources.zombie_growls[soundSources.zombie_growl_index];
                     if (growlSynth.state === 'stopped') {
                        growlSynth.volume.value = volume;
                        growlSynth.triggerAttackRelease("G0", "1s", Tone.now());
                        soundSources.zombie_growl_index = (soundSources.zombie_growl_index + 1) % soundSources.zombie_growls.length;
                    }
                }


                // --- Player Attack Collision ---
                if (distanceToPlayer < 2.0 && this.attackCooldown <= 0) {
                    if (duelState.localPlayer) {
                        duelState.localPlayer.takeDamage(this.damage);
                        this.attackCooldown = 1.5; // 1.5 second between attacks
                    }
                }
            }

            takeDamage(amount) {
                this.health -= amount;
                if (this.health <= 0) {
                    this.die();
                }
            }

            die() {
                scene.remove(this.mesh);
                // Find and remove this zombie from the main array
                const index = zombieModeState.zombies.indexOf(this);
                if (index > -1) {
                    zombieModeState.zombies.splice(index, 1);
                }
                if(isAudioReady && soundSources.zombie_deaths) {
                    const deathSynth = soundSources.zombie_deaths[soundSources.zombie_death_index];
                     if (deathSynth.state === 'stopped') {
                        deathSynth.triggerAttackRelease("F#1", "4n", Tone.now());
                        soundSources.zombie_death_index = (soundSources.zombie_death_index + 1) % soundSources.zombie_deaths.length;
                    }
                }
                zombieModeState.kills++;
                document.getElementById('zombie-kills-display').textContent = zombieModeState.kills;
            }
        }

        function startZombieMode(playerClass = 'soldier') {
            console.log(`Starting Zombie Mode with class: ${playerClass}`);
            changeSpeed(1);
            preZombieState.mode = state.mode;
            preZombieState.currentTime = state.currentTime;
            zombieModeStartTime = performance.now();

            zombieModeState.active = true;
            zombieModeState.round = 0;
            zombieModeState.kills = 0;
            zombieModeState.zombies = [];

            // Setup UI
            document.body.classList.add('duel-active');
            document.querySelectorAll('.controls').forEach(c => c.classList.add('hidden'));
            timerDisplay.classList.add('timer-display-duel');
            document.getElementById('zombie-hud').classList.remove('hidden');
            localPlayerDuelHud.classList.remove('hidden');
            duelModeBtn.classList.add('hidden');
            classSelectionModal.classList.remove('active');

            // Setup Player
            duelState.localPlayer = new PlayerController(true, playerClass);
            duelState.localPlayer.respawn();
            enableShooterControls();
            
            // Start the game
            startNextWave();
            if (!state.isRunning) {
                startTimer();
            }
        }

        function endZombieMode(showResults = true, resetTimerState = true) {
            if (!zombieModeState.active) return;
            console.log("Ending Zombie Mode.");
            
            if (showResults) {
                document.getElementById('results-modal-round').textContent = zombieModeState.round;
                document.getElementById('results-modal-kills').textContent = zombieModeState.kills;
                document.getElementById('zombie-results-modal').classList.add('active');
            }

            zombieModeState.active = false;
            zombieModeState.zombies.forEach(z => scene.remove(z.mesh));
            zombieModeState.zombies = [];

            document.body.classList.remove('duel-active');
            disableShooterControls();
            
            if (duelState.localPlayer) {
                duelState.localPlayer.dispose();
                duelState.localPlayer = null;
            }

            // Restore UI
            document.getElementById('zombie-hud').classList.add('hidden');
            localPlayerDuelHud.classList.add('hidden');
            timerDisplay.classList.remove('timer-display-duel');
            document.querySelectorAll('.controls').forEach(c => c.classList.remove('hidden'));
            
            if(resetTimerState) {
                // Restore the timer to its pre-zombie state, but paused.
                pauseTimer();
                const elapsedTime = (performance.now() - zombieModeStartTime) / 1000;
                state.currentTime = Math.round(Math.max(0, preZombieState.currentTime - elapsedTime));
                updateTimerDisplay();
            }
            updateSinglePlayerDuelButtonVisibility();
        }

        function startNextWave() {
            zombieModeState.round++;
            zombieModeState.waveTimer = zombieModeState.waveInterval;
            
            zombieModeState.zombiesToSpawn = Math.floor(3 + zombieModeState.round * 1.5);

            for (let i = 0; i < zombieModeState.zombiesToSpawn; i++) {
                const zombie = new ZombieController();
                zombieModeState.zombies.push(zombie);
            }

            document.getElementById('zombie-round-display').textContent = zombieModeState.round;
            document.getElementById('zombie-kills-display').textContent = zombieModeState.kills;
            console.log(`Starting Round ${zombieModeState.round} with ${zombieModeState.zombiesToSpawn} zombies.`);
        }


    </script>
</body>
</html>

